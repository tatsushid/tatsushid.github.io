<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      tatsushid.github.io
    
  </title>

  
  <link rel="stylesheet" href="/css/poole.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="stylesheet" href="/css/lanyon.css">
  <link rel="stylesheet" href="/css/overwrite.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  <link rel="stylesheet" href="/css/styles/zenburn.css">

  
  <script src="/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/favicon.ico">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://tatsushid.github.io/index.xml/">
</head>


  <body class="theme-base-0d layout-reverse sidebar-overlay">

    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>   </p>
  </div>

  <nav class="sidebar-nav">
    <ul>
      <li><a class="sidebar-nav-item active" href="/">Home</a></li>

      
      <li>
        <a class="sidebar-nav-item" href="/blog/">Blog</a>
        
      </li>
      
      <li>
        <a class="sidebar-nav-item" href="/tags/">Tags</a>
        
      </li>
      

    </ul>
  </nav>

  <div class="sidebar-item">
    <p>
       &copy; 2014. Tatsushi Demachi All rights reserved. 
    </p>
  </div>
</div>


    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">tatsushid.github.io</a>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/09/go-structure-pointer-and-omitempty/">
      Go の構造体とポインタと omitempty の話
    </a>
  </h1>

  <div class="post-meta">
    2014-09-23
    <ul>
    
      <li><a href="/tags/golang">golang</a></li>
    </span>
    </ul>
  </div>

  

<p>（下記は go 1.3.1 での話で、異なるバージョンだと動作も違う可能性があるので注意）</p>

<h2 id="toc_0">結論</h2>

<p>Go で <code>encoding/xml</code> を使って XML のエンコーディングを行っている時に、</p>

<ul>
<li>ある特定のタグの子要素ないし属性が一つでもある場合は、そのタグを出力する</li>
<li>上記のいずれもない場合は、タグは出力しない</li>
</ul>

<p>を実現したい場合は、単純に要素のポインタ型を使って <code>omitempty</code> は使わないのが正解</p>

<h2 id="toc_1">詳細</h2>

<p>上記のケースを最初は単純に</p>

<pre><code class="go">package main

import (
	&quot;encoding/xml&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

type Foo struct {
	Str string
}

type Bar struct {
	Foo Foo `xml:&quot;,omitempty&quot;`
}

func main() {
	bar := Bar{} // Foo は空
	b, err := xml.MarshalIndent(bar, &quot;&quot;, &quot;  &quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b)) // &lt;Bar&gt;&lt;/Bar&gt; と出力されてほしい
	// Output:
	// &lt;Bar&gt;
	//   &lt;Foo&gt;
	//     &lt;Str&gt;&lt;/Str&gt;
	//   &lt;/Foo&gt;
	// &lt;/Bar&gt;
}
</code></pre>

<p>としてみたのだけど、うまくいかなかった。理由は <a href="http://golang.org/pkg/encoding/xml/">encoding/xml</a> のドキュメントによると</p>

<blockquote>
<ul>
<li>a field with a tag including the &ldquo;omitempty&rdquo; option is omitted
if the field value is empty. The empty values are false, 0, any
nil pointer or interface value, and any array, slice, map, or
string of length zero.</li>
</ul>
</blockquote>

<p>ということで、空の構造体と比較してはくれないためのよう。ここで対象が <code>nil</code> ポインタなら空と扱う、と書いてあるので、</p>

<pre><code class="go">package main

import (
	&quot;encoding/xml&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

type Foo struct {
	Str string
}

type Bar struct {
	Foo *Foo `xml:&quot;,omitempty&quot;` // omitempty はあってもなくてもよい
}

func main() {
	bar := Bar{} // Foo は nil
	b, err := xml.MarshalIndent(bar, &quot;&quot;, &quot;  &quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b)) // &lt;Bar&gt;&lt;/Bar&gt; と出力されてほしい
	// Output:
	// &lt;Bar&gt;&lt;/Bar&gt;

	bar.Foo = new(Foo)
	b, err := xml.MarshalIndent(bar, &quot;&quot;, &quot;  &quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &lt;Bar&gt;
	//   &lt;Foo&gt;
	//     &lt;Str&gt;&lt;/Str&gt;
	//   &lt;/Foo&gt;
	// &lt;/Bar&gt;
}
</code></pre>

<p>と、 <code>Foo</code> のポインタを構造体に含めるようにしてみるとうまく動く。もちろん要素がある場合も問題なく動く。さらに、この場合は別に <code>omitempty</code> なしでも意図通りの動作になる</p>

<p>ところが、たとえば構造体の要素が <code>int</code> で、</p>

<ul>
<li><code>int</code> の要素が 0 である場合は、要素があるとみなして出力する（つまり <code>omitempty</code> を無視する）</li>
<li><code>int</code> の要素そのものが存在しない時は出力しない</li>
</ul>

<p>の場合は、同じようにやっても期待通りにはならない。 <code>int</code> が 0 の場合は <code>omitempty</code> の対象として扱ってしまう</p>

<pre><code class="go">package main

import (
	&quot;encoding/xml&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

type Foo struct {
	Bar *int `xml:&quot;,omitempty&quot;`
}

func main() {
	foo := Foo{}
	b, err := xml.MarshalIndent(foo, &quot;&quot;, &quot;  &quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &lt;Foo&gt;&lt;/Foo&gt;

	foo.Bar = new(int)
	*(foo.Bar) = 0
	b, err = xml.MarshalIndent(foo, &quot;&quot;, &quot;  &quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &lt;Foo&gt;&lt;/Foo&gt;
}
</code></pre>

<p>この場合は、要素の型をポインタ型にしつつ、素直に <code>omitempty</code> を外すか、ポインタのポインタを使うと意図通りの結果が得られるようだ</p>

<pre><code class="go">package main

import (
	&quot;encoding/xml&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

type Foo struct {
	Bar *int
	Baz **int `xml:&quot;,omitempty&quot;`
}

func main() {
	foo := Foo{}
	b, err := xml.MarshalIndent(foo, &quot;&quot;, &quot;  &quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &lt;Foo&gt;&lt;/Foo&gt;

	foo.Bar = new(int)
	*(foo.Bar) = 0
	tmp := new(int)
	*tmp = 0
	foo.Baz = &amp;tmp
	b, err = xml.MarshalIndent(foo, &quot;&quot;, &quot;  &quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &lt;Foo&gt;
	//   &lt;Bar&gt;0&lt;/Bar&gt;
	//   &lt;Baz&gt;0&lt;/Baz&gt;
	// &lt;/Foo&gt;
}
</code></pre>

<p>いろいろとややこしい</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/09/how-to-get-reflect-type-of-interface-type-in-go/">
      Go でインターフェース型の reflect.Type を取得する方法
    </a>
  </h1>

  <div class="post-meta">
    2014-09-19
    <ul>
    
      <li><a href="/tags/golang">golang</a></li>
    </span>
    </ul>
  </div>

  <p>Go の <code>reflect</code> パッケージを使っていて、ときどき操作している変数型との比較のために <code>error</code> などのインターフェース型の <code>reflect.Type</code> がほしいことがあるのだけれど、これは <code>reflect.TypeOf((*error)(nil)).Elem()</code> のように書くことで得られる。つまり、</p>

<ul>
<li><code>nil</code> をほしい型のポインタ型に変換</li>
<li>それを <code>reflect.TypeOf</code> に渡してポインタ型の <code>reflect.Type</code> を取得し</li>
<li><code>Elem()</code> でポインタをデリファレンスしてできる基本型の <code>reflect.Type</code> を得る</li>
</ul>

<p>という流れ。 Go の公式パッケージではよく見かける書法。これを使うと、たとえば変数が <code>error</code> インターフェースを満たすかどうかの判定は</p>

<pre><code class="go">package main

import (
        &quot;errors&quot;
        &quot;fmt&quot;
        &quot;reflect&quot;
)

func main() {
	err := errors.New(&quot;A problem occurs&quot;)
	et := reflect.TypeOf(err)
	if et.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
		fmt.Println(&quot;This is an error type&quot;)
	} else {
		fmt.Println(&quot;This isn't an error type&quot;)
	}
}
</code></pre>

<p>のように書ける。もちろん、これはリフレクションを操作してる時の話で、普通は</p>

<pre><code class="go">package main

import (
        &quot;errors&quot;
        &quot;fmt&quot;
)

func main() {
	err := errors.New(&quot;A problem occurs&quot;)
	if _, ok := err.(error); ok {
		fmt.Println(&quot;This is an error type&quot;)
	} else {
		fmt.Println(&quot;This isn't an error type&quot;)
	}
}
</code></pre>

<p>とするのがよい</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/09/how-to-check-centos-mirrorlist/">
      CentOSのyumミラーリストの調べ方
    </a>
  </h1>

  <div class="post-meta">
    2014-09-18
    <ul>
    
      <li><a href="/tags/centos">centos</a></li>
    </span>
    </ul>
  </div>

  <p>ここ最近 CentOS の yum で updates からパッケージを持ってくる時の速度がやけに遅いので、 yum にはどんなミラーが返ってきてるのか調べてみた。 yum は 64bit 環境で特別設定を変えてなければ、通常 <code>http://mirrorlist.centos.org/?release=6&amp;arch=x86_64&amp;repo=os</code> や <code>http://mirrorlist.centos.org/?release=6&amp;arch=x86_64&amp;repo=updates</code> にアクセスしているので、この URL にブラウザでアクセスするか、</p>

<pre><code class="sh">curl 'http://mirrorlist.centos.org/?release=6&amp;arch=x86_64&amp;repo=os'
</code></pre>

<p>のように <code>curl</code> を使えば、ミラーの一覧が返る。 <code>release</code> は CentOS のメジャーバージョン、 <code>arch</code> は <code>i386</code> や <code>x86_64</code> などのアーキテクチャ、 <code>repo</code> はリポジトリの種類をそれぞれ指定できる。さらに、 URL に <code>cc=jp</code> や <code>ip=8.8.8.8</code> などのクエリを追加すると、国コード別、 IP アドレス別のミラーリストを返してくれるらしい。たとえば、</p>

<pre><code class="sh">curl 'http://mirrorlist.centos.org/?release=6&amp;arch=x86_64&amp;repo=os&amp;cc=jp' # 国コード別
curl 'http://mirrorlist.centos.org/?release=6&amp;arch=x86_64&amp;repo=os&amp;ip=8.8.8.8' # IP アドレス別
</code></pre>

<p>などとすると、それぞれの結果が返る。なお、今日の時点 (2014-09-18) で os の方は</p>

<pre><code>http://ftp.nara.wide.ad.jp/pub/Linux/centos/6.5/os/x86_64/
http://ftp.tsukuba.wide.ad.jp/Linux/centos/6.5/os/x86_64/
http://ftp.iij.ad.jp/pub/linux/centos/6.5/os/x86_64/
http://ftp.jaist.ac.jp/pub/Linux/CentOS/6.5/os/x86_64/
http://ftp.riken.jp/Linux/centos/6.5/os/x86_64/
http://www.ftp.ne.jp/Linux/packages/CentOS/6.5/os/x86_64/
http://mirror.fairway.ne.jp/centos/6.5/os/x86_64/
http://mirror.vodien.com/centos/6.5/os/x86_64/
http://mirror.nus.edu.sg/centos/6.5/os/x86_64/
http://centos.mirror.secureax.com/6.5/os/x86_64/
</code></pre>

<p>のような結果が返ってくるが、 updates の方はなぜか</p>

<pre><code>http://mirrors.hust.edu.cn/centos/6.5/updates/x86_64/
http://mirrors.yun-idc.com/centos/6.5/updates/x86_64/
http://centos.mirror.cdnetworks.com/6.5/updates/x86_64/
http://ftp.yzu.edu.tw/Linux/CentOS/6.5/updates/x86_64/
http://ftp.isu.edu.tw/pub/Linux/CentOS/6.5/updates/x86_64/
http://mirror.awanti.com/centos/6.5/updates/x86_64/
</code></pre>

<p>のようなリストを返してきてて、国内ミラーを使ってくれてないのが速度が出てない理由なのかな、と</p>

<p>余談だけど、各国のミラーの状態は <a href="http://mirror-status.centos.org/">http://mirror-status.centos.org/</a> で見れる</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/08/change-site-generator-to-hugo/">
      静的サイトジェネレーターを Hugo に切り替えた
    </a>
  </h1>

  <div class="post-meta">
    2014-08-16
    <ul>
    
      <li><a href="/tags/hugo">Hugo</a></li>
    
      <li><a href="/tags/golang">golang</a></li>
    </span>
    </ul>
  </div>

  <p>ここ半年から一年の間、ちょっとしたコマンドラインツールの開発にはずっと golang を使ってきてて、せっかくなのでサイトジェネレーターもこの際 golang 製に変えてみようということで、 <a href="http://hugo.spf13.com/">Hugo</a> を使ってみることにした。今のところの使用感としては、</p>

<ul>
<li>バイナリ拾ってくるだけなのでインストール簡単</li>
<li>サイト生成速度が速い！</li>
<li><a href="http://jekyllrb.com/">Jekyll</a> と同様に Front Matter がある（各ページのメタデータを定義できるもの）</li>
<li>他のツールにもあるが、ローカルサーバでのプレビュー機能便利</li>
<li>他のツールほどメジャーではないせいか、既成のテンプレートが少ない (´；ω；｀)</li>
<li>Go 標準のテンプレートパッケージ使ってるためか、テンプレートでいろいろやろうとすると制約が厳しい</li>
</ul>

<p>といったところ。 golang の特質はそのままのため、がんばって言語環境整備しなくても、 Windows とか他のプラットフォームでも同じように使えるのはいいところだと思う。コード量もそれほどではないので、自分で機能を追加するのもそれほど難しくない</p>

<p>一方でテンプレートは本当に選択肢が少なすぎるので、勉強も兼ねて、 <a href="http://jekyllrb.com/">Jekyll</a> 用のテーマの <a href="http://lanyon.getpoole.com/">Lanyon</a> を移植して、それにちょっとだけ手を加えたものを使うことにした。こちらは気が向いたら公開したい</p>

<p>このテンプレートを作っていてわかったのは、 golang 標準の text/template と派生の html/template のテンプレートパッケージでは、書式自体は分かりやすくていいものの、制御構文が少なかったり定義した変数のスコープの絡みとかでいろいろと制約があり、プログラム側に手を入れて補助関数を作らないと、単純なものでも機能実現できないものが多々あるなあというところ。この辺りは、ロジックはあくまでプログラム側で処理し、テンプレートはそれを表示するだけだ、という考え方でできているのだと思うが、ちょっとしたカスタマイズでプログラム自体に手を入れなければいけないのは、メンテナンスの面でちょっとつらい。柔軟性の高い補助関数とかが Hugo 本家に入るのを見ていくしかないのかな、という気もする</p>

<p>ともあれ、 Hugo 自体は必要十分な機能がよくまとまっていて、何よりサイト生成が早いこともあって、気軽に何度でもトライアンドエラーを繰り返して試せるので、個人的には気に入っている。しばらくいろいろ試してみたいと思う</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/08/specify-wget-savedir/">
      wgetでの保存先ディレクトリを指定する
    </a>
  </h1>

  <div class="post-meta">
    2014-08-11
    <ul>
    
      <li><a href="/tags/cli">cli</a></li>
    </span>
    </ul>
  </div>

  <p>wget コマンドを使っていると、たまにカレントディレクトリではなくて他の場所にデータを保存したい時があるのだけれど、その方法をしばしば忘れるのでメモ。これをやりたい時は、 -P オプションを使えばよい。たとえば</p>

<pre><code class="bash">wget -P path/to/dstdir http://localhost/path/to/srcfile.tar.gz
</code></pre>

<p>の様に実行すると、 <code>path/to/dstdir/srcfile.tar.gz</code> の様に保存される</p>

</div>

          
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

<script>
  (function(document) {
    var toggle = document.querySelector('.sidebar-toggle');
    var sidebar = document.querySelector('#sidebar');
    var checkbox = document.querySelector('#sidebar-checkbox');

    document.addEventListener('click', function(e) {
      var target = e.target;

      if(!checkbox.checked ||
         sidebar.contains(target) ||
         (target === checkbox || target === toggle)) return;

      checkbox.checked = false;
    }, false);
  })(document);
</script>


  </body>
</html>
