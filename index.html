<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      tatsushid.github.io
    
  </title>

  
  <link rel="stylesheet" href="/css/poole.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="stylesheet" href="/css/lanyon.css">
  <link rel="stylesheet" href="/css/overwrite.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  <link rel="stylesheet" href="/css/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/styles/zenburn.css">

  
  <script src="/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/favicon.ico">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://tatsushid.github.io/index.xml">
</head>


  <body class="theme-base-0d layout-reverse sidebar-overlay">

    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>   </p>
  </div>

  <nav class="sidebar-nav">
    <ul>
      <li><a class="sidebar-nav-item active" href="/">Home</a></li>

      
      <li>
        <a class="sidebar-nav-item" href="http://tatsushid.github.io/blog/">Blog</a>
        
      </li>
      
      <li>
        <a class="sidebar-nav-item" href="http://tatsushid.github.io/tags/">Tags</a>
        
      </li>
      

    </ul>
  </nav>

  <div class="sidebar-item">
    <ul class="media-links">
      <li><a href="https://twitter.com/tatsushi_d"><i class="fa fa-twitter" aria-label="twitter"></i></a></li>
      <li><a href="https://github.com/tatsushid"><i class="fa fa-github" aria-label="github"></i></a></li>
    </ul>
    <div class="footnote">
      Powered by <a href="http://gohugo.io/">Hugo</a><br>
      &copy; 2014-2015. Tatsushi Demachi All rights reserved.
    </div>
  </div>
</div>


    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">tatsushid.github.io</a>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2015/01/managing-libreboard-containers-by-fig/">
      Fig で Libreboard 環境を構築してみた
    </a>
  </h1>

  <div class="post-meta">
    2015-01-18
    <ul>
    
      <li><a href="/tags/docker">Docker</a></li>
    
      <li><a href="/tags/fig">Fig</a></li>
    
      <li><a href="/tags/libreboard">Libreboard</a></li>
    
    </ul>
  </div>

  <p><a href="/blog/2015/01/run-libreboard-on-docker/">前回</a> は Docker 上で Libreboard を動かしてみたが、今のところ Libreboard の開発は非常に活発で、更新を Docker コンテナに反映させるたびに長々としたコマンドを叩くのが不便に感じてきたため、 <a href="http://www.fig.sh/">Fig</a> を使って必要なコマンドなどをあらかじめ定義しておき、 <code>fig build</code> や <code>fig up</code> で楽に更新適用ができるようにしてみた。以下はその手順</p>

<ol>
<li>Fig をインストール。今回は手元のサーバが Gentoo だったので emerge で入れてしまったが、 <a href="http://www.fig.sh/install.html">Installing Fig</a> を見る限り、他の環境でも簡単に導入できると思う</li>

<li><p>Fig の作業ディレクトリを適当に作成して移動する</p>

<pre><code>mkdir fig_libreboard
cd fig_libreboard
</code></pre></li>

<li><p><code>fig.yml</code> を作成する。今回は下記のようにしてみた</p>

<pre><code class="language-yaml">libreboard:
  build: ../libreboard
  links:
    - mongo
  ports:
    - &quot;5555:8080&quot;
  environment:
    ROOT_URL: &quot;http://libreboard.example.com&quot;
  command: &quot;sh -c 'export MONGO_URL=mongodb://$MONGO_PORT_27017_TCP_ADDR:$MONGO_PORT_27017_TCP_PORT/libreboard; /meteor-run.sh'&quot;
data:
  image: busybox
  volumes:
    - /data/db
backup:
  image: busybox
  volumes_from:
    - data
mongo:
  image: mongo
  volumes_from:
    - data
  entrypoint: mongod
</code></pre>

<p><code>libreboard</code>, <code>data</code>, <code>backup</code>, <code>mongo</code> の 4 台構成になっている。それぞれの役割は、</p>

<ul>
<li><code>libreboard</code> はアプリケーションを稼働させるコンテナ。先ほど作った <code>fig_libreboard</code> と同一階層の <code>libreboard</code> ディレクトリにある Dockerfile を読み込んで Docker イメージを構築し、それを実行する。データストアとなる MongoDB コンテナとリンクして、起動時に環境変数経由で接続を行っている。</li>
<li><code>data</code> は <a href="https://docs.docker.com/userguide/dockervolumes/">Managing data in containers - Docker Documentation</a> で言うところのデータボリュームコンテナで、 MongoDB のデータを保持するためだけに使われている。</li>
<li><code>mongo</code> は実際に MongoDB が稼働するコンテナ。 <code>data</code> のボリュームに接続してデータをそこに保存している。</li>
<li><code>backup</code> は、 <code>data</code> からは <code>/data/db</code> の中身が見えなかったため、確認作業などのために便宜上作成しておいたコンテナ。これがあると気軽に <code>fig run --rm backup ls -al /data/db</code> などと打って中身を確認したり、 tar でのバックアップ作業がやりやすくなる。が、特別稼働そのものには関係ないので、なくてもかまわない</li>
</ul>

<p>といったところ。起動コマンドやポートの設定は <a href="/blog/2015/01/run-libreboard-on-docker/">前回</a> のものを引き継ぐ形で指定している</p></li>

<li><p>上記設定ができたら、 <code>fig up</code> を実行してコンテナ群を起動する。初回は <code>libreboard</code> コンテナ用のイメージのビルドが実行されるので、少しばかり時間がかかる。無事に起動してウェブブラウザで 5555 番ポートにアクセスしてログイン画面が出れば成功。バックグラウンドでの起動に切り替えたい場合は、いったん <code>Ctrl-c</code> を入力してコンテナ群を停止し、改めて <code>fig up -d</code> で起動すればよい。</p></li>

<li><p>Libreboard の更新があった場合は <code>fig build</code> を実行して Docker イメージを再作成する。イメージ作成に成功したら <code>fig up -d</code> を実行して環境を再起動すればよい</p></li>
</ol>

<p>Fig を使うと、このような感じで一度 <code>fig.yml</code> を書くだけで、機能ごとに分割した複数のコンテナを保持しつつ、日常の操作は簡単な <code>fig</code> コマンドを実行するだけで済むようになる。今回の Libreboard に限らず、 Fig を使うことでホスト側の環境にあれこれ手を入れずとも気軽にウェブアプリケーションの実行環境を用意できるので、単一ホスト内で実行させたいウェブアプリケーションの管理には非常に優れていると思う</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2015/01/run-libreboard-on-docker/">
      Docker で Libreboard 動かしてみた
    </a>
  </h1>

  <div class="post-meta">
    2015-01-12
    <ul>
    
      <li><a href="/tags/docker">Docker</a></li>
    
      <li><a href="/tags/libreboard">Libreboard</a></li>
    
    </ul>
  </div>

  <p>昨日「 <a href="http://www.ryuzee.com/contents/blog/7032">オープンソースのTrelloクローン Libreboard | Ryuzee.com</a> 」の記事を読んで面白そうだと思ったので、 Docker で動かしてみた。一手間かかったけど動かすことはできたので、以下その手順。 Docker はインストールされてることを前提</p>

<ol>
<li><p><a href="https://github.com/libreboard/libreboard">Libreboard</a> のリポジトリをクローンして手元に落としてくる</p>

<pre><code>git clone https://github.com/libreboard/libreboard.git
</code></pre></li>

<li><p>落としてきた Libreboard のディレクトリに移動し Docker イメージを作成する</p>

<pre><code>cd libreboard
docker build -t libreboard .
</code></pre></li>

<li><p>Libreboard は MongoDB をデータ保存に使用しているので、 MongoDB の Docker イメージも用意して起動しておく</p>

<pre><code>docker pull mongo
docker run --name mymongo -d mongo
</code></pre>

<p>環境によっては起動時に <code>numactl: This system does not support NUMA policy</code> といわれて起動できないことがあるので、その場合は</p>

<pre><code>docker run --name mymongo --entrypoint=mongod -d mongo
</code></pre>

<p>という形で直接 MongoDB を起動するとよい（参考： <a href="http://stackoverflow.com/questions/27882091/docker-mongo-exits-on-run">mongodb - Docker: Mongo exits on run - Stack Overflow</a> ）</p></li>

<li><p>あらかじめ作成しておいた Libreboard の Docker イメージを使ってコンテナを起動する</p>

<pre><code>docker run -dit --link mymongo:mongo -e ROOT_URL=&quot;http://example.com&quot; -p 5555:8080 libreboard sh -c 'export MONGO_URL=mongodb://$MONGO_PORT_27017_TCP_ADDR:$MONGO_PORT_27017_TCP_PORT/libreboard; /meteor-run.sh'
</code></pre>

<p>docker の <code>--link</code> オプションを使うと、起動したコンテナ内に link で接続した先のコンテナから環境変数が渡されてくるので、それを使って <code>MONGO_URL</code> 環境変数を定義する。 Docker の <code>-e</code> オプションだとコンテナ内部の変数は展開できなさそうだったため、コマンド実行時に定義している。 <code>ROOT_URL</code> はとりあえず適当なものに。</p></li>
</ol>

<p>上記の手順後、 Docker サーバの 5555 ポートにウェブブラウザでアクセスすると、めでたくログイン画面が表示された</p>

<p>Libreboard 自体は確かにまだまだ機能不足な点が否めないが、使い勝手はよさそうだったので今後が楽しみである</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2015/01/how-to-convert-markdown-into-mediawiki/">
      Pandoc を使って Markdown を Mediawiki に変換する方法
    </a>
  </h1>

  <div class="post-meta">
    2015-01-05
    <ul>
    
      <li><a href="/tags/pandoc">Pandoc</a></li>
    
      <li><a href="/tags/markdown">Markdown</a></li>
    
      <li><a href="/tags/mediawiki">Mediawiki</a></li>
    
    </ul>
  </div>

  <p>あまり頻度の高くない作業だけど、ちょいちょい必要になりそうなため、忘れないようにメモ。 Markdown で書いたドキュメントは、 <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a> を使うと Mediawiki の書式に変換できる。たとえば</p>

<pre><code class="language-sh">pandoc -f markdown -t mediawiki -o sample.mediawiki sample.md
</code></pre>

<p>のようにコマンドを実行すると、 <code>sample.md</code> を <code>sample.mediawiki</code> のファイルへ形式変換して出力してくれる。変換後の書式などはおおむね問題ないが、意図通りじゃない部分もところどころ見られるので、中身はチェックした方がよい。 MacOS X を使っているのなら、変換後のファイルの中身を</p>

<pre><code class="language-sh">cat sample.mediawiki | pbcopy
</code></pre>

<p>としてクリップボードに取り込んでしまえるので、 Wiki の入力フォームに張りつけることも簡単にできる。もちろん逆の変換も</p>

<pre><code class="language-sh">pandoc -f mediawiki -t markdown -o sample.md sample.mediawiki
</code></pre>

<p>のようにできる</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/10/time-piece-problem-at-parsing-date-header-in-a-mail/">
      メールの Date ヘッダを Time::Piece でパースしようとしてはまった話
    </a>
  </h1>

  <div class="post-meta">
    2014-10-16
    <ul>
    
      <li><a href="/tags/perl">Perl</a></li>
    
    </ul>
  </div>

  

<p>メールに含まれている Date ヘッダを Perl の Time::Piece でパースしようとしたところ、タイムゾーンがうまく扱えなくてはまった。たとえば、</p>

<pre><code class="language-perl">#!/usr/bin/env perl

use strict;
use warnings;

use POSIX qw(setlocale LC_TIME);
use Time::Piece;

setlocale(LC_TIME, &quot;C&quot;);

my $format = '%a, %e %b %Y %T %z';
my $datetime = &quot;Tue, 14 Oct 2014 18:23:53 +0900&quot;;
my $t = Time::Piece-&gt;strptime($datetime, $format);
print $t-&gt;strftime($format), &quot;\n&quot;;
</code></pre>

<p>とした時、元と同じ結果が返ってくることが期待されるが、実際には <code>Tue, 14 Oct 2014 09:23:53 +0900</code> となって、 JST の 9 時間分ずれる。この辺については</p>

<ul>
<li><a href="http://d.hatena.ne.jp/hirose31/20110210/1297341952">Time::Piece とタイムゾーンの甘い罠</a></li>
<li><a href="http://qiita.com/dayflower/items/199252df1ab759bd318e">Time::Piece に関するとりとめのないコト</a></li>
</ul>

<p>など多々まとめがあるが、一応自分でも Time::Piece のコードを読んで確認したことと、とりあえずの回避策をメモしておきたい。なお、検証は Perl 5.18.2 と現時点での Time::Piece 最新版である 1.29 を使って行っている</p>

<h2 id="回避策:f982ae70135bfa8403b8ce10daa2a9de">回避策</h2>

<p>検証部分が長いので、まず回避策を先に書いてしまうが、結論としては先ほどのコードを</p>

<pre><code class="language-perl">#!/usr/bin/env perl

use strict;
use warnings;

use POSIX qw(setlocale LC_TIME);
use Time::Piece;

setlocale(LC_TIME, &quot;C&quot;);

my $format = '%a, %e %b %Y %T %z';
my $datetime = &quot;Tue, 14 Oct 2014 18:23:53 +0900&quot;;
my $t = localtime(Time::Piece-&gt;strptime($datetime, $format)-&gt;epoch);
print $t-&gt;strftime($format), &quot;\n&quot;;
</code></pre>

<p>のように書き換えればよい、と言うことになる。パースした結果の <code>epoch</code> を取り出して <code>localhost</code> （ Time::Piece でオーバーライドされてる）に渡せば、内部的には自身のタイムゾーンの値としてうまく扱ってくれる。以下はその理由</p>

<h2 id="検証:f982ae70135bfa8403b8ce10daa2a9de">検証</h2>

<h3 id="strptime-の-z-で何をやっているか:f982ae70135bfa8403b8ce10daa2a9de">strptime の %z で何をやっているか</h3>

<p>関連記事を読むと、 <code>%z</code> を使ってる時に問題が出るケースが多く、かつ、この例でも使ってるので、まずはそこを調べてみる。 <code>Piece.xs</code> によると、 <code>strptime</code> の内部実装 <code>_strptime</code> は</p>

<pre><code class="language-xs">void
_strptime ( string, format )
        char * string
        char * format
  PREINIT:
       struct tm mytm;
       time_t t;
       char * remainder;
       int got_GMT;
  PPCODE:
       t = 0;
       mytm = *gmtime(&amp;t);
       got_GMT = 0;

       remainder = (char *)_strptime(aTHX_ string, format, &amp;mytm, &amp;got_GMT);
       if (remainder == NULL) {
           croak(&quot;Error parsing time&quot;);
       }
       if (*remainder != '\0') {
           warn(&quot;garbage at end of string in strptime: %s&quot;, remainder);
       }

       return_11part_tm(aTHX_ SP, &amp;mytm);
       return;
</code></pre>

<p>となっていて、 <code>gmtime</code> として初期化されている。さらにここで呼んでいる <code>_strptime</code> の中では、 <code>%z</code> の処理は</p>

<pre><code class="language-c">case 'z':
        {
        int sign = 1;

        if (*buf != '+') {
                if (*buf == '-')
                        sign = -1;
                else
                        return 0;
        }

        buf++;
        i = 0;
        for (len = 4; len &gt; 0; len--) {
                if (isdigit((int)*buf)) {
                        i *= 10;
                        i += *buf - '0';
                        buf++;
                } else
                        return 0;
        }

        tm-&gt;tm_hour -= sign * (i / 100);
        tm-&gt;tm_min  -= sign * (i % 100);
        *got_GMT = 1;
        }
        break;
}
</code></pre>

<p>となっていて、つまり <code>+0900</code> の部分を時と分に分解して元の時と分の値を調整した後、 <code>GMT</code> として扱うようフラグを立てている。従って内部的には <code>GMT</code> で正しく計算された値が入っていることになる</p>

<h3 id="strftime-は何をやっているか:f982ae70135bfa8403b8ce10daa2a9de">strftime は何をやっているか</h3>

<p>では、出力を生成している <code>strftime</code> で何をやっているかというと、 <code>Piece.pm</code> では</p>

<pre><code class="language-perl">sub strftime {
    my $time = shift;
    my $tzname = $time-&gt;[c_islocal] ? '%Z' : 'UTC';
    my $format = @_ ? shift(@_) : &quot;%a, %d %b %Y %H:%M:%S $tzname&quot;;
    if (!defined $time-&gt;[c_wday]) {
        if ($time-&gt;[c_islocal]) {
            return _strftime($format, CORE::localtime($time-&gt;epoch));
        }
        else {
            return _strftime($format, CORE::gmtime($time-&gt;epoch));
        }
    }
    return _strftime($format, (@$time)[c_sec..c_isdst]);
}
</code></pre>

<p>となっていて、この場合、 <code>strptime</code> で <code>GMT</code> として生成されたものを <code>_strftime($format, CORE::gmtime($time-&gt;epoch))</code> という形で渡すことになる。 <code>_strptime</code> は <code>Piece.xs</code> で定義されていて、</p>

<pre><code class="language-xs">void
_strftime(fmt, sec, min, hour, mday, mon, year, wday = -1, yday = -1, isdst = -1)
    char *        fmt
    int        sec
    int        min
    int        hour
    int        mday
    int        mon
    int        year
    int        wday
    int        yday
    int        isdst
    CODE:
    {
        char tmpbuf[128];
        struct tm mytm;
        int len;
        memset(&amp;mytm, 0, sizeof(mytm));
        my_init_tm(&amp;mytm);    /* XXX workaround - see my_init_tm() above */
        mytm.tm_sec = sec;
        mytm.tm_min = min;
        mytm.tm_hour = hour;
        mytm.tm_mday = mday;
        mytm.tm_mon = mon;
        mytm.tm_year = year;
        mytm.tm_wday = wday;
        mytm.tm_yday = yday;
        mytm.tm_isdst = isdst;
        my_mini_mktime(&amp;mytm);
        len = strftime(tmpbuf, sizeof tmpbuf, fmt, &amp;mytm);
</code></pre>

<p>となっているが、どうやら <code>my_init_tm</code> （この関数は Perl 5.8.0 以降では Perl 本体の <code>util.c</code> に定義されている <code>init_tm</code> のエイリアスになっている）でローカルタイムとして定義した後、 C 標準関数の <code>strftime</code> を呼び出しており、そこで <code>%z</code> は実行環境のタイムゾーンである <code>+0900</code> を返してくることになる。つまり、 <code>GMT</code> の時刻 + 実行環境のタイムゾーンが生成されていて、これがおかしな表示の理由ということになる。</p>

<h3 id="gmtime-を-localtime-に変換する:f982ae70135bfa8403b8ce10daa2a9de">gmtime を localtime に変換する</h3>

<p>ここまでの結果からズレを直すには</p>

<ul>
<li>時刻はそのまま、タイムゾーンとして <code>GMT</code>, <code>UTC</code>, <code>+0000</code> が返ってくるようにする</li>
<li>タイムゾーンはそのまま、時刻をローカルタイムに変換する</li>
</ul>

<p>のどちらかを取ればよさそうだということがわかった。前者については GitHub に Time::Piece への <a href="https://github.com/rjbs/Time-Piece/pull/3">Pull Request</a> があって、これがマージされれば解消できるように見える。ここでは後者について考えたい。</p>

<p>まず、単純に</p>

<pre><code class="language-perl">my $format = '%a, %e %b %Y %T %z';
my $datetime = &quot;Tue, 14 Oct 2014 18:23:53 +0900&quot;;
my $t = localtime(Time::Piece-&gt;strptime($datetime, $format));
</code></pre>

<p>としてみたが、これはうまくいかなかった。 <code>Piece.pm</code> を見ると</p>

<pre><code class="language-perl">sub localtime {
    unshift @_, __PACKAGE__ unless eval { $_[0]-&gt;isa('Time::Piece') };
    my $class = shift;
    my $time  = shift;
    $time = time if (!defined $time);
    $class-&gt;_mktime($time, 1);
}

sub _mktime {
    my ($class, $time, $islocal) = @_;
    $class = eval { (ref $class) &amp;&amp; (ref $class)-&gt;isa('Time::Piece') }
           ? ref $class
           : $class;
    if (ref($time)) {
        $time-&gt;[c_epoch] = undef;
        return wantarray ? @$time : bless [@$time[0..9], $islocal], $class;
    }
    _tzset();
    my @time = $islocal ?
            CORE::localtime($time)
                :
            CORE::gmtime($time);
    wantarray ? @time : bless [@time, $time, $islocal], $class;
}
</code></pre>

<p>となっていて、 <code>$time</code> が Time::Piece オブジェクトの場合、 <code>$islocal</code> フラグを立てて単に中身をコピーしてるだけ、ということなので、これだと時刻のズレはそのままフラグが立ってしまうという結果になる。これを回避するためには、</p>

<pre><code class="language-perl">my $format = '%a, %e %b %Y %T %z';
my $datetime = &quot;Tue, 14 Oct 2014 18:23:53 +0900&quot;;
my $t = localtime(Time::Piece-&gt;strptime($datetime, $format)-&gt;epoch);
</code></pre>

<p>としてエポックタイムを渡すようにし、 <code>_mktime</code> の <code>CORE::localtime($time)</code> を通るようにしてやればよい。結果、前述の回避策、ということになる</p>

<h2 id="まとめ:f982ae70135bfa8403b8ce10daa2a9de">まとめ</h2>

<p>一つ一つ Time::Piece のコードを読んでいった結果、なんとか当初の目的は達成できた。が、標準モジュールとして入っている割には Time::Piece は細かな挙動が読めなくて使うのが難しいなとは感じた</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/10/switch-from-official-go-vim-plugin-to-vim-go/">
      Go の Vim プラグインを vim-go に切り替えた
    </a>
  </h1>

  <div class="post-meta">
    2014-10-13
    <ul>
    
      <li><a href="/tags/golang">Golang</a></li>
    
      <li><a href="/tags/vim">Vim</a></li>
    
    </ul>
  </div>

  <p>Vim で Go のコードを書いていて、エディタ内からお手軽にカバレッジ取れたらいいなと思って調べていたら、オフィシャルの Go の Vim プラグインではなく <a href="https://github.com/fatih/vim-go">vim-go</a> を使えばできそうだということがわかったので、切り替えることにした</p>

<p>まずは</p>

<pre><code class="language-vim">&quot; Set golang vim scripts
exe 'set runtimepath+='.substitute(system('brew --prefix go'), '\n', '', 'g').'/libexec/misc/vim'
</code></pre>

<p>として読み込んでいたオフィシャルプラグインを外して、自分の環境ではプラグイン管理に <a href="https://github.com/Shougo/neobundle.vim">NeoBundle</a> を使っているので</p>

<pre><code class="language-vim">NeoBundleLazy 'fatih/vim-go', {
       \ 'depends' : 'majutsushi/tagbar',
       \ 'autoload' : {
       \   'filetypes' : 'go',
       \   'commands' : ['GoInstallBinaries', 'GoUpdateBinaries'],
       \ }}

&quot; vim-go &quot;{{{
let bundle = neobundle#get('vim-go')
function! bundle.hooks.on_source(bundle)
       let g:go_fmt_autosave = 0
       let g:go_fmt_fail_silently = 1
endfunction
&quot;}}}
</code></pre>

<p>のように設定してみた。 <a href="http://majutsushi.github.io/tagbar/">Tagbar</a> を使っている場合は <code>depends</code> に一緒に読み込む設定を書いておくことで、 <a href="https://github.com/jstemmer/gotags">gotags</a> を使ったアウトライン表示ができる。また、当初の目的だったカバレッジ取得は、 <code>:GoCoverage</code> を実行すれば自動的にウェブブラウザが開いて結果を表示してくれるようになっている</p>

<p>他にも支援プログラムを使った各種機能が盛りだくさんで、仮にそれらに必要なソフトウェアがインストールされていない場合は <code>:GoInstallBinaries</code> を実行すれば、内部的に <code>go get</code> して必要なパッケージを拾ってきてインストールしてくれる。それらの一括更新も <code>:GoUpdateBinaries</code> で実行できて便利</p>

<p>これでちょっとばかり Go を書く環境がリッチになったので、しばらく使い込んでみたい</p>

</div>

          
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

<script>
  (function(document) {
    var toggle = document.querySelector('.sidebar-toggle');
    var sidebar = document.querySelector('#sidebar');
    var checkbox = document.querySelector('#sidebar-checkbox');

    document.addEventListener('click', function(e) {
      var target = e.target;

      if(!checkbox.checked ||
         sidebar.contains(target) ||
         (target === checkbox || target === toggle)) return;

      checkbox.checked = false;
    }, false);
  })(document);
</script>


  </body>
</html>
