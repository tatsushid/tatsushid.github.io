<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      tatsushid.github.io
    
  </title>

  
  <link rel="stylesheet" href="/css/poole.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="stylesheet" href="/css/lanyon.css">
  <link rel="stylesheet" href="/css/overwrite.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  <link rel="stylesheet" href="/css/styles/zenburn.css">

  
  <script src="/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/favicon.ico">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://tatsushid.github.io/index.xml">
</head>


  <body class="theme-base-0d layout-reverse sidebar-overlay">

    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>   </p>
  </div>

  <nav class="sidebar-nav">
    <ul>
      <li><a class="sidebar-nav-item active" href="/">Home</a></li>

      
      <li>
        <a class="sidebar-nav-item" href="http://tatsushid.github.io/blog/">Blog</a>
        
      </li>
      
      <li>
        <a class="sidebar-nav-item" href="http://tatsushid.github.io/tags/">Tags</a>
        
      </li>
      

    </ul>
  </nav>

  <div class="sidebar-item">
    <p>
       &copy; 2014. Tatsushi Demachi All rights reserved. 
    </p>
  </div>
</div>


    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">tatsushid.github.io</a>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2015/01/how-to-convert-markdown-into-mediawiki/">
      Pandoc を使って Markdown を Mediawiki に変換する方法
    </a>
  </h1>

  <div class="post-meta">
    2015-01-05
    <ul>
    
      <li><a href="/tags/pandoc">Pandoc</a></li>
    
      <li><a href="/tags/markdown">Markdown</a></li>
    
      <li><a href="/tags/mediawiki">Mediawiki</a></li>
    
    </ul>
  </div>

  <p>あまり頻度の高くない作業だけど、ちょいちょい必要になりそうなため、忘れないようにメモ。 Markdown で書いたドキュメントは、 <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a> を使うと Mediawiki の書式に変換できる。たとえば</p>

<pre><code class="language-sh">pandoc -f markdown -t mediawiki -o sample.mediawiki sample.md
</code></pre>

<p>のようにコマンドを実行すると、 <code>sample.md</code> を <code>sample.mediawiki</code> のファイルへ形式変換して出力してくれる。変換後の書式などはおおむね問題ないが、意図通りじゃない部分もところどころ見られるので、中身はチェックした方がよい。 MacOS X を使っているのなら、変換後のファイルの中身を</p>

<pre><code class="language-sh">cat sample.mediawiki | pbcopy
</code></pre>

<p>としてクリップボードに取り込んでしまえるので、 Wiki の入力フォームに張りつけることも簡単にできる。もちろん逆の変換も</p>

<pre><code class="language-sh">pandoc -f mediawiki -t markdown -o sample.md sample.mediawiki
</code></pre>

<p>のようにできる</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/10/time-piece-problem-at-parsing-date-header-in-a-mail/">
      メールの Date ヘッダを Time::Piece でパースしようとしてはまった話
    </a>
  </h1>

  <div class="post-meta">
    2014-10-16
    <ul>
    
      <li><a href="/tags/perl">Perl</a></li>
    
    </ul>
  </div>

  

<p>メールに含まれている Date ヘッダを Perl の Time::Piece でパースしようとしたところ、タイムゾーンがうまく扱えなくてはまった。たとえば、</p>

<pre><code class="language-perl">#!/usr/bin/env perl

use strict;
use warnings;

use POSIX qw(setlocale LC_TIME);
use Time::Piece;

setlocale(LC_TIME, &quot;C&quot;);

my $format = '%a, %e %b %Y %T %z';
my $datetime = &quot;Tue, 14 Oct 2014 18:23:53 +0900&quot;;
my $t = Time::Piece-&gt;strptime($datetime, $format);
print $t-&gt;strftime($format), &quot;\n&quot;;
</code></pre>

<p>とした時、元と同じ結果が返ってくることが期待されるが、実際には <code>Tue, 14 Oct 2014 09:23:53 +0900</code> となって、 JST の 9 時間分ずれる。この辺については</p>

<ul>
<li><a href="http://d.hatena.ne.jp/hirose31/20110210/1297341952">Time::Piece とタイムゾーンの甘い罠</a></li>
<li><a href="http://qiita.com/dayflower/items/199252df1ab759bd318e">Time::Piece に関するとりとめのないコト</a></li>
</ul>

<p>など多々まとめがあるが、一応自分でも Time::Piece のコードを読んで確認したことと、とりあえずの回避策をメモしておきたい。なお、検証は Perl 5.18.2 と現時点での Time::Piece 最新版である 1.29 を使って行っている</p>

<h2 id="回避策:f982ae70135bfa8403b8ce10daa2a9de">回避策</h2>

<p>検証部分が長いので、まず回避策を先に書いてしまうが、結論としては先ほどのコードを</p>

<pre><code class="language-perl">#!/usr/bin/env perl

use strict;
use warnings;

use POSIX qw(setlocale LC_TIME);
use Time::Piece;

setlocale(LC_TIME, &quot;C&quot;);

my $format = '%a, %e %b %Y %T %z';
my $datetime = &quot;Tue, 14 Oct 2014 18:23:53 +0900&quot;;
my $t = localtime(Time::Piece-&gt;strptime($datetime, $format)-&gt;epoch);
print $t-&gt;strftime($format), &quot;\n&quot;;
</code></pre>

<p>のように書き換えればよい、と言うことになる。パースした結果の <code>epoch</code> を取り出して <code>localhost</code> （ Time::Piece でオーバーライドされてる）に渡せば、内部的には自身のタイムゾーンの値としてうまく扱ってくれる。以下はその理由</p>

<h2 id="検証:f982ae70135bfa8403b8ce10daa2a9de">検証</h2>

<h3 id="strptime-の-z-で何をやっているか:f982ae70135bfa8403b8ce10daa2a9de">strptime の %z で何をやっているか</h3>

<p>関連記事を読むと、 <code>%z</code> を使ってる時に問題が出るケースが多く、かつ、この例でも使ってるので、まずはそこを調べてみる。 <code>Piece.xs</code> によると、 <code>strptime</code> の内部実装 <code>_strptime</code> は</p>

<pre><code class="language-xs">void
_strptime ( string, format )
        char * string
        char * format
  PREINIT:
       struct tm mytm;
       time_t t;
       char * remainder;
       int got_GMT;
  PPCODE:
       t = 0;
       mytm = *gmtime(&amp;t);
       got_GMT = 0;

       remainder = (char *)_strptime(aTHX_ string, format, &amp;mytm, &amp;got_GMT);
       if (remainder == NULL) {
           croak(&quot;Error parsing time&quot;);
       }
       if (*remainder != '\0') {
           warn(&quot;garbage at end of string in strptime: %s&quot;, remainder);
       }

       return_11part_tm(aTHX_ SP, &amp;mytm);
       return;
</code></pre>

<p>となっていて、 <code>gmtime</code> として初期化されている。さらにここで呼んでいる <code>_strptime</code> の中では、 <code>%z</code> の処理は</p>

<pre><code class="language-c">case 'z':
        {
        int sign = 1;

        if (*buf != '+') {
                if (*buf == '-')
                        sign = -1;
                else
                        return 0;
        }

        buf++;
        i = 0;
        for (len = 4; len &gt; 0; len--) {
                if (isdigit((int)*buf)) {
                        i *= 10;
                        i += *buf - '0';
                        buf++;
                } else
                        return 0;
        }

        tm-&gt;tm_hour -= sign * (i / 100);
        tm-&gt;tm_min  -= sign * (i % 100);
        *got_GMT = 1;
        }
        break;
}
</code></pre>

<p>となっていて、つまり <code>+0900</code> の部分を時と分に分解して元の時と分の値を調整した後、 <code>GMT</code> として扱うようフラグを立てている。従って内部的には <code>GMT</code> で正しく計算された値が入っていることになる</p>

<h3 id="strftime-は何をやっているか:f982ae70135bfa8403b8ce10daa2a9de">strftime は何をやっているか</h3>

<p>では、出力を生成している <code>strftime</code> で何をやっているかというと、 <code>Piece.pm</code> では</p>

<pre><code class="language-perl">sub strftime {
    my $time = shift;
    my $tzname = $time-&gt;[c_islocal] ? '%Z' : 'UTC';
    my $format = @_ ? shift(@_) : &quot;%a, %d %b %Y %H:%M:%S $tzname&quot;;
    if (!defined $time-&gt;[c_wday]) {
        if ($time-&gt;[c_islocal]) {
            return _strftime($format, CORE::localtime($time-&gt;epoch));
        }
        else {
            return _strftime($format, CORE::gmtime($time-&gt;epoch));
        }
    }
    return _strftime($format, (@$time)[c_sec..c_isdst]);
}
</code></pre>

<p>となっていて、この場合、 <code>strptime</code> で <code>GMT</code> として生成されたものを <code>_strftime($format, CORE::gmtime($time-&gt;epoch))</code> という形で渡すことになる。 <code>_strptime</code> は <code>Piece.xs</code> で定義されていて、</p>

<pre><code class="language-xs">void
_strftime(fmt, sec, min, hour, mday, mon, year, wday = -1, yday = -1, isdst = -1)
    char *        fmt
    int        sec
    int        min
    int        hour
    int        mday
    int        mon
    int        year
    int        wday
    int        yday
    int        isdst
    CODE:
    {
        char tmpbuf[128];
        struct tm mytm;
        int len;
        memset(&amp;mytm, 0, sizeof(mytm));
        my_init_tm(&amp;mytm);    /* XXX workaround - see my_init_tm() above */
        mytm.tm_sec = sec;
        mytm.tm_min = min;
        mytm.tm_hour = hour;
        mytm.tm_mday = mday;
        mytm.tm_mon = mon;
        mytm.tm_year = year;
        mytm.tm_wday = wday;
        mytm.tm_yday = yday;
        mytm.tm_isdst = isdst;
        my_mini_mktime(&amp;mytm);
        len = strftime(tmpbuf, sizeof tmpbuf, fmt, &amp;mytm);
</code></pre>

<p>となっているが、どうやら <code>my_init_tm</code> （この関数は Perl 5.8.0 以降では Perl 本体の <code>util.c</code> に定義されている <code>init_tm</code> のエイリアスになっている）でローカルタイムとして定義した後、 C 標準関数の <code>strftime</code> を呼び出しており、そこで <code>%z</code> は実行環境のタイムゾーンである <code>+0900</code> を返してくることになる。つまり、 <code>GMT</code> の時刻 + 実行環境のタイムゾーンが生成されていて、これがおかしな表示の理由ということになる。</p>

<h3 id="gmtime-を-localtime-に変換する:f982ae70135bfa8403b8ce10daa2a9de">gmtime を localtime に変換する</h3>

<p>ここまでの結果からズレを直すには</p>

<ul>
<li>時刻はそのまま、タイムゾーンとして <code>GMT</code>, <code>UTC</code>, <code>+0000</code> が返ってくるようにする</li>
<li>タイムゾーンはそのまま、時刻をローカルタイムに変換する</li>
</ul>

<p>のどちらかを取ればよさそうだということがわかった。前者については GitHub に Time::Piece への <a href="https://github.com/rjbs/Time-Piece/pull/3">Pull Request</a> があって、これがマージされれば解消できるように見える。ここでは後者について考えたい。</p>

<p>まず、単純に</p>

<pre><code class="language-perl">my $format = '%a, %e %b %Y %T %z';
my $datetime = &quot;Tue, 14 Oct 2014 18:23:53 +0900&quot;;
my $t = localtime(Time::Piece-&gt;strptime($datetime, $format));
</code></pre>

<p>としてみたが、これはうまくいかなかった。 <code>Piece.pm</code> を見ると</p>

<pre><code class="language-perl">sub localtime {
    unshift @_, __PACKAGE__ unless eval { $_[0]-&gt;isa('Time::Piece') };
    my $class = shift;
    my $time  = shift;
    $time = time if (!defined $time);
    $class-&gt;_mktime($time, 1);
}

sub _mktime {
    my ($class, $time, $islocal) = @_;
    $class = eval { (ref $class) &amp;&amp; (ref $class)-&gt;isa('Time::Piece') }
           ? ref $class
           : $class;
    if (ref($time)) {
        $time-&gt;[c_epoch] = undef;
        return wantarray ? @$time : bless [@$time[0..9], $islocal], $class;
    }
    _tzset();
    my @time = $islocal ?
            CORE::localtime($time)
                :
            CORE::gmtime($time);
    wantarray ? @time : bless [@time, $time, $islocal], $class;
}
</code></pre>

<p>となっていて、 <code>$time</code> が Time::Piece オブジェクトの場合、 <code>$islocal</code> フラグを立てて単に中身をコピーしてるだけ、ということなので、これだと時刻のズレはそのままフラグが立ってしまうという結果になる。これを回避するためには、</p>

<pre><code class="language-perl">my $format = '%a, %e %b %Y %T %z';
my $datetime = &quot;Tue, 14 Oct 2014 18:23:53 +0900&quot;;
my $t = localtime(Time::Piece-&gt;strptime($datetime, $format)-&gt;epoch);
</code></pre>

<p>としてエポックタイムを渡すようにし、 <code>_mktime</code> の <code>CORE::localtime($time)</code> を通るようにしてやればよい。結果、前述の回避策、ということになる</p>

<h2 id="まとめ:f982ae70135bfa8403b8ce10daa2a9de">まとめ</h2>

<p>一つ一つ Time::Piece のコードを読んでいった結果、なんとか当初の目的は達成できた。が、標準モジュールとして入っている割には Time::Piece は細かな挙動が読めなくて使うのが難しいなとは感じた</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/10/switch-from-official-go-vim-plugin-to-vim-go/">
      Go の Vim プラグインを vim-go に切り替えた
    </a>
  </h1>

  <div class="post-meta">
    2014-10-13
    <ul>
    
      <li><a href="/tags/golang">Golang</a></li>
    
      <li><a href="/tags/vim">Vim</a></li>
    
    </ul>
  </div>

  <p>Vim で Go のコードを書いていて、エディタ内からお手軽にカバレッジ取れたらいいなと思って調べていたら、オフィシャルの Go の Vim プラグインではなく <a href="https://github.com/fatih/vim-go">vim-go</a> を使えばできそうだということがわかったので、切り替えることにした</p>

<p>まずは</p>

<pre><code class="language-vim">&quot; Set golang vim scripts
exe 'set runtimepath+='.substitute(system('brew --prefix go'), '\n', '', 'g').'/libexec/misc/vim'
</code></pre>

<p>として読み込んでいたオフィシャルプラグインを外して、自分の環境ではプラグイン管理に <a href="https://github.com/Shougo/neobundle.vim">NeoBundle</a> を使っているので</p>

<pre><code class="language-vim">NeoBundleLazy 'fatih/vim-go', {
       \ 'depends' : 'majutsushi/tagbar',
       \ 'autoload' : {
       \   'filetypes' : 'go',
       \   'commands' : ['GoInstallBinaries', 'GoUpdateBinaries'],
       \ }}

&quot; vim-go &quot;{{{
let bundle = neobundle#get('vim-go')
function! bundle.hooks.on_source(bundle)
       let g:go_fmt_autosave = 0
       let g:go_fmt_fail_silently = 1
endfunction
&quot;}}}
</code></pre>

<p>のように設定してみた。 <a href="http://majutsushi.github.io/tagbar/">Tagbar</a> を使っている場合は <code>depends</code> に一緒に読み込む設定を書いておくことで、 <a href="https://github.com/jstemmer/gotags">gotags</a> を使ったアウトライン表示ができる。また、当初の目的だったカバレッジ取得は、 <code>:GoCoverage</code> を実行すれば自動的にウェブブラウザが開いて結果を表示してくれるようになっている</p>

<p>他にも支援プログラムを使った各種機能が盛りだくさんで、仮にそれらに必要なソフトウェアがインストールされていない場合は <code>:GoInstallBinaries</code> を実行すれば、内部的に <code>go get</code> して必要なパッケージを拾ってきてインストールしてくれる。それらの一括更新も <code>:GoUpdateBinaries</code> で実行できて便利</p>

<p>これでちょっとばかり Go を書く環境がリッチになったので、しばらく使い込んでみたい</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/10/how-to-build-centos3-docker-image/">
      CentOS 3 の Docker イメージを作ってみた
    </a>
  </h1>

  <div class="post-meta">
    2014-10-04
    <ul>
    
      <li><a href="/tags/docker">Docker</a></li>
    
      <li><a href="/tags/centos">CentOS</a></li>
    
    </ul>
  </div>

  

<p>先日の Bash 脆弱性騒ぎに関連して、ごく一部で残ってる RHEL3 系のマシンにも Bash のパッチを当てざるを得ない状況が発生したため、この際パッケージビルド用の Docker イメージも作っておくか、ということでやってみた</p>

<h2 id="必要なもの:0f9548c31060b9cf09120147eb98969b">必要なもの</h2>

<ul>
<li>CentOS 3 がインストールされているサーバないし仮想マシン</li>
<li>Yum パッケージ</li>
<li>CentOS 3 のパッケージが含まれているリポジトリへのアクセス</li>
</ul>

<p>CentOS 3 のマシンは楽にやるには必須だと思う。初めは CentOS 6 上でやってみたが、後述のスクリプト実行時に最新の CentOS 6 のパッケージを拾ってこようとするのをうまく回避できなかったので、結局 CentOS 3 上で作業を行った</p>

<h2 id="作成の流れ:0f9548c31060b9cf09120147eb98969b">作成の流れ</h2>

<p>といっても、ほとんどやることはなくて、だいたい以下に集約される</p>

<ul>
<li><code>yum.conf</code> を編集して CentOS 3 パッケージが含まれているリポジトリを参照するようにする</li>
<li>Docker プロジェクトが提供している <a href="https://github.com/docker/docker/blob/master/contrib/mkimage-yum.sh">mkimage-yum.sh</a> を持ってきて、 CentOS 3 向けにカスタマイズする</li>
<li>スクリプト実行して <code>os_image.tar.gz</code> を得る</li>
<li>できた <code>os_image.tar.gz</code> を Docker に食わせてイメージ化する</li>
</ul>

<p>以下、個々の作業の説明</p>

<h3 id="yum-conf-の編集:0f9548c31060b9cf09120147eb98969b">yum.conf の編集</h3>

<p>サーバ内に Yum が入っていなければ、まずはこれが必須なので入れておくのだが、 CentOS 3 はもうメンテされていないので、パッケージを拾ってこれるミラーサーバを <code>yum.conf</code> に設定しておかなければならない。普通は <code>http://vault.centos.org/</code> を設定しておけばいいと思うが、当たるミラーによってはかなり遅いことになるので、場合によっては速度の出るミラーサーバの IP アドレスを <code>dig</code> なりなんなりで調べて直接 IP アドレスを指定しておく必要があるかもしれない。具体的な変更は <code>yum.conf</code> 内にいくつかある</p>

<pre><code>baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
</code></pre>

<p>みたいな行を</p>

<pre><code>baseurl=http://vault.centos.org/3.9/os/i386/
</code></pre>

<p>のように書き換えておくだけである</p>

<h3 id="mkimage-yum-sh-のカスタマイズ:0f9548c31060b9cf09120147eb98969b">mkimage-yum.sh のカスタマイズ</h3>

<p>一番手間取ったのがここだったが、わかってしまえばなんということもない内容。書き換えたスクリプトはこんな感じ</p>

<script src="https://gist.github.com/tatsushid/22d169ea1e91e8941773.js"></script>

<p>はまったポイントは</p>

<ul>
<li>mktemp が古いためにオプションの扱いが違う。最初気付かずやって、それなりの量のシステムファイルを消してしまった…</li>
<li>パッケージを検証する GPG KEY を Yum が勝手には拾ってきてくれないので、自分で先に対象ディレクトリに落としておく</li>
<li>なぜか Docker にインポートした後 RPM DB が壊れているようだったので、 <code>yum clean</code> 後に <code>rpm --rebuilddb</code> を実行しておく</li>
<li>ldconfig キャッシュは消してもいいが、できたイメージをすぐ使いたい時は、ライブラリが見つからなくていちいち再構築も面倒なので、残しておく</li>
</ul>

<p>といったところ</p>

<h3 id="スクリプトの実行:0f9548c31060b9cf09120147eb98969b">スクリプトの実行</h3>

<p>これはそのまんま、上記で作成しておいた <code>yum.conf</code> を <code>mkimage-yum.sh</code> に指定して実行するだけである。うまくいけば <code>os_image.tar.gz</code> がカレントディレクトリ内に作られる</p>

<h3 id="docker-でイメージ化:0f9548c31060b9cf09120147eb98969b">Docker でイメージ化</h3>

<p>できた <code>os_image.tar.gz</code> を Docker が動いている環境に持ってきて、下記のようにコマンドを実行する</p>

<pre><code class="language-bash">cat os_image.tar.gz | docker import - centos-3-i386
</code></pre>

<p><code>centos-3-i386</code> の部分はイメージ名になるので、好きなように設定すればよい。インポートに成功したら、</p>

<pre><code class="language-bash">docker run -i -t centos-3-i386 /bin/bash
</code></pre>

<p>のようにして使い始めることができる</p>

<h2 id="まとめ:0f9548c31060b9cf09120147eb98969b">まとめ</h2>

<p>上記の流れでできたイメージを使って、無事パッチ済みの Bash の RPM の作成もできたので、日常の作業には十分な環境が作成できたと思う</p>

<p>Docker のイメージを作ったのは初めてだったが、 OS が稼働するのに必要なファイル群を tar に固めて食わせるだけ、というのは手軽でいい。各種ディストリビューションごとにマイクロ環境を作れるようなツールがあったりするので、それを使えば気楽にイメージが作れるだろうな、と思う</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/09/source-ip-address-affinty-configuration-in-haproxy/">
      HAProxy でのソース IP アドレスアフィニティ設定方法
    </a>
  </h1>

  <div class="post-meta">
    2014-09-29
    <ul>
    
      <li><a href="/tags/haproxy">HAProxy</a></li>
    
    </ul>
  </div>

  

<p>HAProxy で、アクセス元のクライアントの IP アドレスを元に、分散先サーバを固定したい場合、 <code>backend</code> または <code>listen</code> セクションで次のように設定すればよい</p>

<h2 id="frontend-と-backend-を分けて設定してる場合:91b8713e75d1ee54903a1ba0ef999c8b">frontend と backend を分けて設定してる場合</h2>

<pre><code>frontend web-front
	bind *:80
	default_backend web-back

backend web-back
	balance source # Affinity setting
	server s1 192.168.1.11:80 check
	server s2 192.168.1.12:80 check
</code></pre>

<h2 id="listen-でまとめて設定している場合:91b8713e75d1ee54903a1ba0ef999c8b">listen でまとめて設定している場合</h2>

<pre><code>listen web
	bind *:80
	balance source # Affinity setting
	server s1 192.168.1.11:80 check
	server s2 192.168.1.12:80 check
</code></pre>

<p>簡単な設定の割にはドキュメントを探すのに結構苦労した</p>

<h2 id="参考にしたページ:91b8713e75d1ee54903a1ba0ef999c8b">参考にしたページ</h2>

<ul>
<li><a href="http://blog.haproxy.com/2012/03/29/load-balancing-affinity-persistence-sticky-sessions-what-you-need-to-know/">load balancing, affinity, persistence, sticky sessions: what you need to know</a></li>
<li><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.5.html#4-balance">HAProxy Configuration Manual</a></li>
</ul>

</div>

          
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

<script>
  (function(document) {
    var toggle = document.querySelector('.sidebar-toggle');
    var sidebar = document.querySelector('#sidebar');
    var checkbox = document.querySelector('#sidebar-checkbox');

    document.addEventListener('click', function(e) {
      var target = e.target;

      if(!checkbox.checked ||
         sidebar.contains(target) ||
         (target === checkbox || target === toggle)) return;

      checkbox.checked = false;
    }, false);
  })(document);
</script>


  </body>
</html>
