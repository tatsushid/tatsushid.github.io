<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      tatsushid.github.io
    
  </title>

  
  <link rel="stylesheet" href="/css/poole.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="stylesheet" href="/css/lanyon.css">
  <link rel="stylesheet" href="/css/overwrite.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  <link rel="stylesheet" href="/css/styles/zenburn.css">

  
  <script src="/js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/favicon.ico">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://tatsushid.github.io/index.xml/">
</head>


  <body class="theme-base-0d layout-reverse sidebar-overlay">

    
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">


<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>   </p>
  </div>

  <nav class="sidebar-nav">
    <ul>
      <li><a class="sidebar-nav-item active" href="/">Home</a></li>

      
      <li>
        <a class="sidebar-nav-item" href="/blog/">Blog</a>
        
      </li>
      
      <li>
        <a class="sidebar-nav-item" href="/tags/">Tags</a>
        
      </li>
      

    </ul>
  </nav>

  <div class="sidebar-item">
    <p>
       &copy; 2014. Tatsushi Demachi All rights reserved. 
    </p>
  </div>
</div>


    
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">tatsushid.github.io</a>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/10/switch-from-official-go-vim-plugin-to-vim-go/">
      Go の Vim プラグインを vim-go に切り替えた
    </a>
  </h1>

  <div class="post-meta">
    2014-10-13
    <ul>
    
      <li><a href="/tags/golang">Golang</a></li>
    
      <li><a href="/tags/vim">Vim</a></li>
    
    </ul>
  </div>

  <p>Vim で Go のコードを書いていて、エディタ内からお手軽にカバレッジ取れたらいいなと思って調べていたら、オフィシャルの Go の Vim プラグインではなく <a href="https://github.com/fatih/vim-go">vim-go</a> を使えばできそうだということがわかったので、切り替えることにした</p>

<p>まずは</p>

<pre><code class="vim">&quot; Set golang vim scripts
exe 'set runtimepath+='.substitute(system('brew --prefix go'), '\n', '', 'g').'/libexec/misc/vim'
</code></pre>

<p>として読み込んでいたオフィシャルプラグインを外して、自分の環境ではプラグイン管理に <a href="https://github.com/Shougo/neobundle.vim">NeoBundle</a> を使っているので</p>

<pre><code class="vim">NeoBundleLazy 'fatih/vim-go', {
       \ 'depends' : 'majutsushi/tagbar',
       \ 'autoload' : {
       \   'filetypes' : 'go',
       \   'commands' : ['GoInstallBinaries', 'GoUpdateBinaries'],
       \ }}

&quot; vim-go &quot;{{{
let bundle = neobundle#get('vim-go')
function! bundle.hooks.on_source(bundle)
       let g:go_fmt_autosave = 0
       let g:go_fmt_fail_silently = 1
endfunction
&quot;}}}
</code></pre>

<p>のように設定してみた。 <a href="http://majutsushi.github.io/tagbar/">Tagbar</a> を使っている場合は <code>depends</code> に一緒に読み込む設定を書いておくことで、 <a href="https://github.com/jstemmer/gotags">gotags</a> を使ったアウトライン表示ができる。また、当初の目的だったカバレッジ取得は、 <code>:GoCoverage</code> を実行すれば自動的にウェブブラウザが開いて結果を表示してくれるようになっている</p>

<p>他にも支援プログラムを使った各種機能が盛りだくさんで、仮にそれらに必要なソフトウェアがインストールされていない場合は <code>:GoInstallBinaries</code> を実行すれば、内部的に <code>go get</code> して必要なパッケージを拾ってきてインストールしてくれる。それらの一括更新も <code>:GoUpdateBinaries</code> で実行できて便利</p>

<p>これでちょっとばかり Go を書く環境がリッチになったので、しばらく使い込んでみたい</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/10/how-to-build-centos3-docker-image/">
      CentOS 3 の Docker イメージを作ってみた
    </a>
  </h1>

  <div class="post-meta">
    2014-10-04
    <ul>
    
      <li><a href="/tags/docker">Docker</a></li>
    
      <li><a href="/tags/centos">CentOS</a></li>
    
    </ul>
  </div>

  

<p>先日の Bash 脆弱性騒ぎに関連して、ごく一部で残ってる RHEL3 系のマシンにも Bash のパッチを当てざるを得ない状況が発生したため、この際パッケージビルド用の Docker イメージも作っておくか、ということでやってみた</p>

<h2 id="toc_0">必要なもの</h2>

<ul>
<li>CentOS 3 がインストールされているサーバないし仮想マシン</li>
<li>Yum パッケージ</li>
<li>CentOS 3 のパッケージが含まれているリポジトリへのアクセス</li>
</ul>

<p>CentOS 3 のマシンは楽にやるには必須だと思う。初めは CentOS 6 上でやってみたが、後述のスクリプト実行時に最新の CentOS 6 のパッケージを拾ってこようとするのをうまく回避できなかったので、結局 CentOS 3 上で作業を行った</p>

<h2 id="toc_1">作成の流れ</h2>

<p>といっても、ほとんどやることはなくて、だいたい以下に集約される</p>

<ul>
<li><code>yum.conf</code> を編集して CentOS 3 パッケージが含まれているリポジトリを参照するようにする</li>
<li>Docker プロジェクトが提供している <a href="https://github.com/docker/docker/blob/master/contrib/mkimage-yum.sh">mkimage-yum.sh</a> を持ってきて、 CentOS 3 向けにカスタマイズする</li>
<li>スクリプト実行して <code>os_image.tar.gz</code> を得る</li>
<li>できた <code>os_image.tar.gz</code> を Docker に食わせてイメージ化する</li>
</ul>

<p>以下、個々の作業の説明</p>

<h3 id="toc_2">yum.conf の編集</h3>

<p>サーバ内に Yum が入っていなければ、まずはこれが必須なので入れておくのだが、 CentOS 3 はもうメンテされていないので、パッケージを拾ってこれるミラーサーバを <code>yum.conf</code> に設定しておかなければならない。普通は <code>http://vault.centos.org/</code> を設定しておけばいいと思うが、当たるミラーによってはかなり遅いことになるので、場合によっては速度の出るミラーサーバの IP アドレスを <code>dig</code> なりなんなりで調べて直接 IP アドレスを指定しておく必要があるかもしれない。具体的な変更は <code>yum.conf</code> 内にいくつかある</p>

<pre><code>baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
</code></pre>

<p>みたいな行を</p>

<pre><code>baseurl=http://vault.centos.org/3.9/os/i386/
</code></pre>

<p>のように書き換えておくだけである</p>

<h3 id="toc_3">mkimage-yum.sh のカスタマイズ</h3>

<p>一番手間取ったのがここだったが、わかってしまえばなんということもない内容。書き換えたスクリプトはこんな感じ</p>

<script src="https://gist.github.com/tatsushid/22d169ea1e91e8941773.js"></script>

<p>はまったポイントは</p>

<ul>
<li>mktemp が古いためにオプションの扱いが違う。最初気付かずやって、それなりの量のシステムファイルを消してしまった…</li>
<li>パッケージを検証する GPG KEY を Yum が勝手には拾ってきてくれないので、自分で先に対象ディレクトリに落としておく</li>
<li>なぜか Docker にインポートした後 RPM DB が壊れているようだったので、 <code>yum clean</code> 後に <code>rpm --rebuilddb</code> を実行しておく</li>
<li>ldconfig キャッシュは消してもいいが、できたイメージをすぐ使いたい時は、ライブラリが見つからなくていちいち再構築も面倒なので、残しておく</li>
</ul>

<p>といったところ</p>

<h3 id="toc_4">スクリプトの実行</h3>

<p>これはそのまんま、上記で作成しておいた <code>yum.conf</code> を <code>mkimage-yum.sh</code> に指定して実行するだけである。うまくいけば <code>os_image.tar.gz</code> がカレントディレクトリ内に作られる</p>

<h3 id="toc_5">Docker でイメージ化</h3>

<p>できた <code>os_image.tar.gz</code> を Docker が動いている環境に持ってきて、下記のようにコマンドを実行する</p>

<pre><code class="bash">cat os_image.tar.gz | docker import - centos-3-i386
</code></pre>

<p><code>centos-3-i386</code> の部分はイメージ名になるので、好きなように設定すればよい。インポートに成功したら、</p>

<pre><code class="bash">docker run -i -t centos-3-i386 /bin/bash
</code></pre>

<p>のようにして使い始めることができる</p>

<h2 id="toc_6">まとめ</h2>

<p>上記の流れでできたイメージを使って、無事パッチ済みの Bash の RPM の作成もできたので、日常の作業には十分な環境が作成できたと思う</p>

<p>Docker のイメージを作ったのは初めてだったが、 OS が稼働するのに必要なファイル群を tar に固めて食わせるだけ、というのは手軽でいい。各種ディストリビューションごとにマイクロ環境を作れるようなツールがあったりするので、それを使えば気楽にイメージが作れるだろうな、と思う</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/09/source-ip-address-affinty-configuration-in-haproxy/">
      HAProxy でのソース IP アドレスアフィニティ設定方法
    </a>
  </h1>

  <div class="post-meta">
    2014-09-29
    <ul>
    
      <li><a href="/tags/haproxy">HAProxy</a></li>
    
    </ul>
  </div>

  

<p>HAProxy で、アクセス元のクライアントの IP アドレスを元に、分散先サーバを固定したい場合、 <code>backend</code> または <code>listen</code> セクションで次のように設定すればよい</p>

<h2 id="toc_0">frontend と backend を分けて設定してる場合</h2>

<pre><code>frontend web-front
	bind *:80
	default_backend web-back

backend web-back
	balance source # Affinity setting
	server s1 192.168.1.11:80 check
	server s2 192.168.1.12:80 check
</code></pre>

<h2 id="toc_1">listen でまとめて設定している場合</h2>

<pre><code>listen web
	bind *:80
	balance source # Affinity setting
	server s1 192.168.1.11:80 check
	server s2 192.168.1.12:80 check
</code></pre>

<p>簡単な設定の割にはドキュメントを探すのに結構苦労した</p>

<h2 id="toc_2">参考にしたページ</h2>

<ul>
<li><a href="http://blog.haproxy.com/2012/03/29/load-balancing-affinity-persistence-sticky-sessions-what-you-need-to-know/">load balancing, affinity, persistence, sticky sessions: what you need to know</a></li>
<li><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.5.html#4-balance">HAProxy Configuration Manual</a></li>
</ul>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/09/go-structure-pointer-and-omitempty/">
      Go の構造体とポインタと omitempty の話
    </a>
  </h1>

  <div class="post-meta">
    2014-09-23
    <ul>
    
      <li><a href="/tags/golang">Golang</a></li>
    
    </ul>
  </div>

  

<p>（下記は go 1.3.1 での話で、異なるバージョンだと動作も違う可能性があるので注意）</p>

<h2 id="toc_0">結論</h2>

<p>Go で <code>encoding/xml</code> を使って XML のエンコーディングを行っている時に、</p>

<ul>
<li>ある特定のタグの子要素ないし属性が一つでもある場合は、そのタグを出力する</li>
<li>上記のいずれもない場合は、タグは出力しない</li>
</ul>

<p>を実現したい場合は、単純に要素のポインタ型を使って <code>omitempty</code> は使わないのが正解</p>

<h2 id="toc_1">詳細</h2>

<p>上記のケースを最初は単純に</p>

<pre><code class="go">package main

import (
	&quot;encoding/xml&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

type Foo struct {
	Str string
}

type Bar struct {
	Foo Foo `xml:&quot;,omitempty&quot;`
}

func main() {
	bar := Bar{} // Foo は空
	b, err := xml.MarshalIndent(bar, &quot;&quot;, &quot;  &quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b)) // &lt;Bar&gt;&lt;/Bar&gt; と出力されてほしい
	// Output:
	// &lt;Bar&gt;
	//   &lt;Foo&gt;
	//     &lt;Str&gt;&lt;/Str&gt;
	//   &lt;/Foo&gt;
	// &lt;/Bar&gt;
}
</code></pre>

<p>としてみたのだけど、うまくいかなかった。理由は <a href="http://golang.org/pkg/encoding/xml/">encoding/xml</a> のドキュメントによると</p>

<blockquote>
<ul>
<li>a field with a tag including the &ldquo;omitempty&rdquo; option is omitted
if the field value is empty. The empty values are false, 0, any
nil pointer or interface value, and any array, slice, map, or
string of length zero.</li>
</ul>
</blockquote>

<p>ということで、空の構造体と比較してはくれないためのよう。ここで対象が <code>nil</code> ポインタなら空と扱う、と書いてあるので、</p>

<pre><code class="go">package main

import (
	&quot;encoding/xml&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

type Foo struct {
	Str string
}

type Bar struct {
	Foo *Foo `xml:&quot;,omitempty&quot;` // omitempty はあってもなくてもよい
}

func main() {
	bar := Bar{} // Foo は nil
	b, err := xml.MarshalIndent(bar, &quot;&quot;, &quot;  &quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b)) // &lt;Bar&gt;&lt;/Bar&gt; と出力されてほしい
	// Output:
	// &lt;Bar&gt;&lt;/Bar&gt;

	bar.Foo = new(Foo)
	b, err := xml.MarshalIndent(bar, &quot;&quot;, &quot;  &quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &lt;Bar&gt;
	//   &lt;Foo&gt;
	//     &lt;Str&gt;&lt;/Str&gt;
	//   &lt;/Foo&gt;
	// &lt;/Bar&gt;
}
</code></pre>

<p>と、 <code>Foo</code> のポインタを構造体に含めるようにしてみるとうまく動く。もちろん要素がある場合も問題なく動く。さらに、この場合は別に <code>omitempty</code> なしでも意図通りの動作になる</p>

<p>ところが、たとえば構造体の要素が <code>int</code> で、</p>

<ul>
<li><code>int</code> の要素が 0 である場合は、要素があるとみなして出力する（つまり <code>omitempty</code> を無視する）</li>
<li><code>int</code> の要素そのものが存在しない時は出力しない</li>
</ul>

<p>の場合は、同じようにやっても期待通りにはならない。 <code>int</code> が 0 の場合は <code>omitempty</code> の対象として扱ってしまう</p>

<pre><code class="go">package main

import (
	&quot;encoding/xml&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

type Foo struct {
	Bar *int `xml:&quot;,omitempty&quot;`
}

func main() {
	foo := Foo{}
	b, err := xml.MarshalIndent(foo, &quot;&quot;, &quot;  &quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &lt;Foo&gt;&lt;/Foo&gt;

	foo.Bar = new(int)
	*(foo.Bar) = 0
	b, err = xml.MarshalIndent(foo, &quot;&quot;, &quot;  &quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &lt;Foo&gt;&lt;/Foo&gt;
}
</code></pre>

<p>この場合は、要素の型をポインタ型にしつつ、素直に <code>omitempty</code> を外すか、ポインタのポインタを使うと意図通りの結果が得られるようだ</p>

<pre><code class="go">package main

import (
	&quot;encoding/xml&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

type Foo struct {
	Bar *int
	Baz **int `xml:&quot;,omitempty&quot;`
}

func main() {
	foo := Foo{}
	b, err := xml.MarshalIndent(foo, &quot;&quot;, &quot;  &quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &lt;Foo&gt;&lt;/Foo&gt;

	foo.Bar = new(int)
	*(foo.Bar) = 0
	tmp := new(int)
	*tmp = 0
	foo.Baz = &amp;tmp
	b, err = xml.MarshalIndent(foo, &quot;&quot;, &quot;  &quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &lt;Foo&gt;
	//   &lt;Bar&gt;0&lt;/Bar&gt;
	//   &lt;Baz&gt;0&lt;/Baz&gt;
	// &lt;/Foo&gt;
}
</code></pre>

<p>いろいろとややこしい</p>

</div>

          
            <div class="post">
  <h1 class="post-title">
    <a href="/blog/2014/09/how-to-get-reflect-type-of-interface-type-in-go/">
      Go でインターフェース型の reflect.Type を取得する方法
    </a>
  </h1>

  <div class="post-meta">
    2014-09-19
    <ul>
    
      <li><a href="/tags/golang">Golang</a></li>
    
    </ul>
  </div>

  <p>Go の <code>reflect</code> パッケージを使っていて、ときどき操作している変数型との比較のために <code>error</code> などのインターフェース型の <code>reflect.Type</code> がほしいことがあるのだけれど、これは <code>reflect.TypeOf((*error)(nil)).Elem()</code> のように書くことで得られる。つまり、</p>

<ul>
<li><code>nil</code> をほしい型のポインタ型に変換</li>
<li>それを <code>reflect.TypeOf</code> に渡してポインタ型の <code>reflect.Type</code> を取得し</li>
<li><code>Elem()</code> でポインタをデリファレンスしてできる基本型の <code>reflect.Type</code> を得る</li>
</ul>

<p>という流れ。 Go の公式パッケージではよく見かける書法。これを使うと、たとえば変数が <code>error</code> インターフェースを満たすかどうかの判定は</p>

<pre><code class="go">package main

import (
        &quot;errors&quot;
        &quot;fmt&quot;
        &quot;reflect&quot;
)

func main() {
	err := errors.New(&quot;A problem occurs&quot;)
	et := reflect.TypeOf(err)
	if et.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
		fmt.Println(&quot;This is an error type&quot;)
	} else {
		fmt.Println(&quot;This isn't an error type&quot;)
	}
}
</code></pre>

<p>のように書ける。もちろん、これはリフレクションを操作してる時の話で、普通は</p>

<pre><code class="go">package main

import (
        &quot;errors&quot;
        &quot;fmt&quot;
)

func main() {
	err := errors.New(&quot;A problem occurs&quot;)
	if _, ok := err.(error); ok {
		fmt.Println(&quot;This is an error type&quot;)
	} else {
		fmt.Println(&quot;This isn't an error type&quot;)
	}
}
</code></pre>

<p>とするのがよい</p>

</div>

          
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

<script>
  (function(document) {
    var toggle = document.querySelector('.sidebar-toggle');
    var sidebar = document.querySelector('#sidebar');
    var checkbox = document.querySelector('#sidebar-checkbox');

    document.addEventListener('click', function(e) {
      var target = e.target;

      if(!checkbox.checked ||
         sidebar.contains(target) ||
         (target === checkbox || target === toggle)) return;

      checkbox.checked = false;
    }, false);
  })(document);
</script>


  </body>
</html>
