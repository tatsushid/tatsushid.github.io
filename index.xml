<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tatsushid.github.io</title>
    <link>http://tatsushid.github.io/</link>
    <description>Recent content on tatsushid.github.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 18 Jan 2015 23:21:58 +0900</lastBuildDate>
    <atom:link href="http://tatsushid.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Fig で Libreboard 環境を構築してみた</title>
      <link>http://tatsushid.github.io/blog/2015/01/managing-libreboard-containers-by-fig/</link>
      <pubDate>Sun, 18 Jan 2015 23:21:58 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2015/01/managing-libreboard-containers-by-fig/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://tatsushid.github.io/blog/2015/01/run-libreboard-on-docker/&#34;&gt;前回&lt;/a&gt; は Docker 上で Libreboard を動かしてみたが、今のところ Libreboard の開発は非常に活発で、更新を Docker コンテナに反映させるたびに長々としたコマンドを叩くのが不便に感じてきたため、 &lt;a href=&#34;http://www.fig.sh/&#34;&gt;Fig&lt;/a&gt; を使って必要なコマンドなどをあらかじめ定義しておき、 &lt;code&gt;fig build&lt;/code&gt; や &lt;code&gt;fig up&lt;/code&gt; で楽に更新適用ができるようにしてみた。以下はその手順&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Fig をインストール。今回は手元のサーバが Gentoo だったので emerge で入れてしまったが、 &lt;a href=&#34;http://www.fig.sh/install.html&#34;&gt;Installing Fig&lt;/a&gt; を見る限り、他の環境でも簡単に導入できると思う&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Fig の作業ディレクトリを適当に作成して移動する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir fig_libreboard
cd fig_libreboard
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;fig.yml&lt;/code&gt; を作成する。今回は下記のようにしてみた&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;libreboard:
  build: ../libreboard
  links:
    - mongo
  ports:
    - &amp;quot;5555:8080&amp;quot;
  environment:
    ROOT_URL: &amp;quot;http://libreboard.example.com&amp;quot;
  command: &amp;quot;sh -c &#39;export MONGO_URL=mongodb://$MONGO_PORT_27017_TCP_ADDR:$MONGO_PORT_27017_TCP_PORT/libreboard; /meteor-run.sh&#39;&amp;quot;
data:
  image: busybox
  volumes:
    - /data/db
backup:
  image: busybox
  volumes_from:
    - data
mongo:
  image: mongo
  volumes_from:
    - data
  entrypoint: mongod
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;libreboard&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;backup&lt;/code&gt;, &lt;code&gt;mongo&lt;/code&gt; の 4 台構成になっている。それぞれの役割は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;libreboard&lt;/code&gt; はアプリケーションを稼働させるコンテナ。先ほど作った &lt;code&gt;fig_libreboard&lt;/code&gt; と同一階層の &lt;code&gt;libreboard&lt;/code&gt; ディレクトリにある Dockerfile を読み込んで Docker イメージを構築し、それを実行する。データストアとなる MongoDB コンテナとリンクして、起動時に環境変数経由で接続を行っている。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; は &lt;a href=&#34;https://docs.docker.com/userguide/dockervolumes/&#34;&gt;Managing data in containers - Docker Documentation&lt;/a&gt; で言うところのデータボリュームコンテナで、 MongoDB のデータを保持するためだけに使われている。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mongo&lt;/code&gt; は実際に MongoDB が稼働するコンテナ。 &lt;code&gt;data&lt;/code&gt; のボリュームに接続してデータをそこに保存している。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;backup&lt;/code&gt; は、 &lt;code&gt;data&lt;/code&gt; からは &lt;code&gt;/data/db&lt;/code&gt; の中身が見えなかったため、確認作業などのために便宜上作成しておいたコンテナ。これがあると気軽に &lt;code&gt;fig run --rm backup ls -al /data/db&lt;/code&gt; などと打って中身を確認したり、 tar でのバックアップ作業がやりやすくなる。が、特別稼働そのものには関係ないので、なくてもかまわない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といったところ。起動コマンドやポートの設定は &lt;a href=&#34;http://tatsushid.github.io/blog/2015/01/run-libreboard-on-docker/&#34;&gt;前回&lt;/a&gt; のものを引き継ぐ形で指定している&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上記設定ができたら、 &lt;code&gt;fig up&lt;/code&gt; を実行してコンテナ群を起動する。初回は &lt;code&gt;libreboard&lt;/code&gt; コンテナ用のイメージのビルドが実行されるので、少しばかり時間がかかる。無事に起動してウェブブラウザで 5555 番ポートにアクセスしてログイン画面が出れば成功。バックグラウンドでの起動に切り替えたい場合は、いったん &lt;code&gt;Ctrl-c&lt;/code&gt; を入力してコンテナ群を停止し、改めて &lt;code&gt;fig up -d&lt;/code&gt; で起動すればよい。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Libreboard の更新があった場合は &lt;code&gt;fig build&lt;/code&gt; を実行して Docker イメージを再作成する。イメージ作成に成功したら &lt;code&gt;fig up -d&lt;/code&gt; を実行して環境を再起動すればよい&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Fig を使うと、このような感じで一度 &lt;code&gt;fig.yml&lt;/code&gt; を書くだけで、機能ごとに分割した複数のコンテナを保持しつつ、日常の操作は簡単な &lt;code&gt;fig&lt;/code&gt; コマンドを実行するだけで済むようになる。今回の Libreboard に限らず、 Fig を使うことでホスト側の環境にあれこれ手を入れずとも気軽にウェブアプリケーションの実行環境を用意できるので、単一ホスト内で実行させたいウェブアプリケーションの管理には非常に優れていると思う&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker で Libreboard 動かしてみた</title>
      <link>http://tatsushid.github.io/blog/2015/01/run-libreboard-on-docker/</link>
      <pubDate>Mon, 12 Jan 2015 10:39:52 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2015/01/run-libreboard-on-docker/</guid>
      <description>&lt;p&gt;昨日「 &lt;a href=&#34;http://www.ryuzee.com/contents/blog/7032&#34;&gt;オープンソースのTrelloクローン Libreboard | Ryuzee.com&lt;/a&gt; 」の記事を読んで面白そうだと思ったので、 Docker で動かしてみた。一手間かかったけど動かすことはできたので、以下その手順。 Docker はインストールされてることを前提&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/libreboard/libreboard&#34;&gt;Libreboard&lt;/a&gt; のリポジトリをクローンして手元に落としてくる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/libreboard/libreboard.git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;落としてきた Libreboard のディレクトリに移動し Docker イメージを作成する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd libreboard
docker build -t libreboard .
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Libreboard は MongoDB をデータ保存に使用しているので、 MongoDB の Docker イメージも用意して起動しておく&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker pull mongo
docker run --name mymongo -d mongo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;環境によっては起動時に &lt;code&gt;numactl: This system does not support NUMA policy&lt;/code&gt; といわれて起動できないことがあるので、その場合は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --name mymongo --entrypoint=mongod -d mongo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という形で直接 MongoDB を起動するとよい（参考： &lt;a href=&#34;http://stackoverflow.com/questions/27882091/docker-mongo-exits-on-run&#34;&gt;mongodb - Docker: Mongo exits on run - Stack Overflow&lt;/a&gt; ）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;あらかじめ作成しておいた Libreboard の Docker イメージを使ってコンテナを起動する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -dit --link mymongo:mongo -e ROOT_URL=&amp;quot;http://example.com&amp;quot; -p 5555:8080 libreboard sh -c &#39;export MONGO_URL=mongodb://$MONGO_PORT_27017_TCP_ADDR:$MONGO_PORT_27017_TCP_PORT/libreboard; /meteor-run.sh&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker の &lt;code&gt;--link&lt;/code&gt; オプションを使うと、起動したコンテナ内に link で接続した先のコンテナから環境変数が渡されてくるので、それを使って &lt;code&gt;MONGO_URL&lt;/code&gt; 環境変数を定義する。 Docker の &lt;code&gt;-e&lt;/code&gt; オプションだとコンテナ内部の変数は展開できなさそうだったため、コマンド実行時に定義している。 &lt;code&gt;ROOT_URL&lt;/code&gt; はとりあえず適当なものに。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上記の手順後、 Docker サーバの 5555 ポートにウェブブラウザでアクセスすると、めでたくログイン画面が表示された&lt;/p&gt;

&lt;p&gt;Libreboard 自体は確かにまだまだ機能不足な点が否めないが、使い勝手はよさそうだったので今後が楽しみである&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pandoc を使って Markdown を Mediawiki に変換する方法</title>
      <link>http://tatsushid.github.io/blog/2015/01/how-to-convert-markdown-into-mediawiki/</link>
      <pubDate>Mon, 05 Jan 2015 20:53:48 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2015/01/how-to-convert-markdown-into-mediawiki/</guid>
      <description>&lt;p&gt;あまり頻度の高くない作業だけど、ちょいちょい必要になりそうなため、忘れないようにメモ。 Markdown で書いたドキュメントは、 &lt;a href=&#34;http://johnmacfarlane.net/pandoc/&#34;&gt;Pandoc&lt;/a&gt; を使うと Mediawiki の書式に変換できる。たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pandoc -f markdown -t mediawiki -o sample.mediawiki sample.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにコマンドを実行すると、 &lt;code&gt;sample.md&lt;/code&gt; を &lt;code&gt;sample.mediawiki&lt;/code&gt; のファイルへ形式変換して出力してくれる。変換後の書式などはおおむね問題ないが、意図通りじゃない部分もところどころ見られるので、中身はチェックした方がよい。 MacOS X を使っているのなら、変換後のファイルの中身を&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat sample.mediawiki | pbcopy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてクリップボードに取り込んでしまえるので、 Wiki の入力フォームに張りつけることも簡単にできる。もちろん逆の変換も&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pandoc -f mediawiki -t markdown -o sample.md sample.mediawiki
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにできる&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>メールの Date ヘッダを Time::Piece でパースしようとしてはまった話</title>
      <link>http://tatsushid.github.io/blog/2014/10/time-piece-problem-at-parsing-date-header-in-a-mail/</link>
      <pubDate>Thu, 16 Oct 2014 00:10:40 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/10/time-piece-problem-at-parsing-date-header-in-a-mail/</guid>
      <description>

&lt;p&gt;メールに含まれている Date ヘッダを Perl の Time::Piece でパースしようとしたところ、タイムゾーンがうまく扱えなくてはまった。たとえば、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;#!/usr/bin/env perl

use strict;
use warnings;

use POSIX qw(setlocale LC_TIME);
use Time::Piece;

setlocale(LC_TIME, &amp;quot;C&amp;quot;);

my $format = &#39;%a, %e %b %Y %T %z&#39;;
my $datetime = &amp;quot;Tue, 14 Oct 2014 18:23:53 +0900&amp;quot;;
my $t = Time::Piece-&amp;gt;strptime($datetime, $format);
print $t-&amp;gt;strftime($format), &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とした時、元と同じ結果が返ってくることが期待されるが、実際には &lt;code&gt;Tue, 14 Oct 2014 09:23:53 +0900&lt;/code&gt; となって、 JST の 9 時間分ずれる。この辺については&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/hirose31/20110210/1297341952&#34;&gt;Time::Piece とタイムゾーンの甘い罠&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/dayflower/items/199252df1ab759bd318e&#34;&gt;Time::Piece に関するとりとめのないコト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;など多々まとめがあるが、一応自分でも Time::Piece のコードを読んで確認したことと、とりあえずの回避策をメモしておきたい。なお、検証は Perl 5.18.2 と現時点での Time::Piece 最新版である 1.29 を使って行っている&lt;/p&gt;

&lt;h2 id=&#34;回避策:f982ae70135bfa8403b8ce10daa2a9de&#34;&gt;回避策&lt;/h2&gt;

&lt;p&gt;検証部分が長いので、まず回避策を先に書いてしまうが、結論としては先ほどのコードを&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;#!/usr/bin/env perl

use strict;
use warnings;

use POSIX qw(setlocale LC_TIME);
use Time::Piece;

setlocale(LC_TIME, &amp;quot;C&amp;quot;);

my $format = &#39;%a, %e %b %Y %T %z&#39;;
my $datetime = &amp;quot;Tue, 14 Oct 2014 18:23:53 +0900&amp;quot;;
my $t = localtime(Time::Piece-&amp;gt;strptime($datetime, $format)-&amp;gt;epoch);
print $t-&amp;gt;strftime($format), &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように書き換えればよい、と言うことになる。パースした結果の &lt;code&gt;epoch&lt;/code&gt; を取り出して &lt;code&gt;localhost&lt;/code&gt; （ Time::Piece でオーバーライドされてる）に渡せば、内部的には自身のタイムゾーンの値としてうまく扱ってくれる。以下はその理由&lt;/p&gt;

&lt;h2 id=&#34;検証:f982ae70135bfa8403b8ce10daa2a9de&#34;&gt;検証&lt;/h2&gt;

&lt;h3 id=&#34;strptime-の-z-で何をやっているか:f982ae70135bfa8403b8ce10daa2a9de&#34;&gt;strptime の %z で何をやっているか&lt;/h3&gt;

&lt;p&gt;関連記事を読むと、 &lt;code&gt;%z&lt;/code&gt; を使ってる時に問題が出るケースが多く、かつ、この例でも使ってるので、まずはそこを調べてみる。 &lt;code&gt;Piece.xs&lt;/code&gt; によると、 &lt;code&gt;strptime&lt;/code&gt; の内部実装 &lt;code&gt;_strptime&lt;/code&gt; は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xs&#34;&gt;void
_strptime ( string, format )
        char * string
        char * format
  PREINIT:
       struct tm mytm;
       time_t t;
       char * remainder;
       int got_GMT;
  PPCODE:
       t = 0;
       mytm = *gmtime(&amp;amp;t);
       got_GMT = 0;

       remainder = (char *)_strptime(aTHX_ string, format, &amp;amp;mytm, &amp;amp;got_GMT);
       if (remainder == NULL) {
           croak(&amp;quot;Error parsing time&amp;quot;);
       }
       if (*remainder != &#39;\0&#39;) {
           warn(&amp;quot;garbage at end of string in strptime: %s&amp;quot;, remainder);
       }

       return_11part_tm(aTHX_ SP, &amp;amp;mytm);
       return;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていて、 &lt;code&gt;gmtime&lt;/code&gt; として初期化されている。さらにここで呼んでいる &lt;code&gt;_strptime&lt;/code&gt; の中では、 &lt;code&gt;%z&lt;/code&gt; の処理は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;case &#39;z&#39;:
        {
        int sign = 1;

        if (*buf != &#39;+&#39;) {
                if (*buf == &#39;-&#39;)
                        sign = -1;
                else
                        return 0;
        }

        buf++;
        i = 0;
        for (len = 4; len &amp;gt; 0; len--) {
                if (isdigit((int)*buf)) {
                        i *= 10;
                        i += *buf - &#39;0&#39;;
                        buf++;
                } else
                        return 0;
        }

        tm-&amp;gt;tm_hour -= sign * (i / 100);
        tm-&amp;gt;tm_min  -= sign * (i % 100);
        *got_GMT = 1;
        }
        break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていて、つまり &lt;code&gt;+0900&lt;/code&gt; の部分を時と分に分解して元の時と分の値を調整した後、 &lt;code&gt;GMT&lt;/code&gt; として扱うようフラグを立てている。従って内部的には &lt;code&gt;GMT&lt;/code&gt; で正しく計算された値が入っていることになる&lt;/p&gt;

&lt;h3 id=&#34;strftime-は何をやっているか:f982ae70135bfa8403b8ce10daa2a9de&#34;&gt;strftime は何をやっているか&lt;/h3&gt;

&lt;p&gt;では、出力を生成している &lt;code&gt;strftime&lt;/code&gt; で何をやっているかというと、 &lt;code&gt;Piece.pm&lt;/code&gt; では&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;sub strftime {
    my $time = shift;
    my $tzname = $time-&amp;gt;[c_islocal] ? &#39;%Z&#39; : &#39;UTC&#39;;
    my $format = @_ ? shift(@_) : &amp;quot;%a, %d %b %Y %H:%M:%S $tzname&amp;quot;;
    if (!defined $time-&amp;gt;[c_wday]) {
        if ($time-&amp;gt;[c_islocal]) {
            return _strftime($format, CORE::localtime($time-&amp;gt;epoch));
        }
        else {
            return _strftime($format, CORE::gmtime($time-&amp;gt;epoch));
        }
    }
    return _strftime($format, (@$time)[c_sec..c_isdst]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていて、この場合、 &lt;code&gt;strptime&lt;/code&gt; で &lt;code&gt;GMT&lt;/code&gt; として生成されたものを &lt;code&gt;_strftime($format, CORE::gmtime($time-&amp;gt;epoch))&lt;/code&gt; という形で渡すことになる。 &lt;code&gt;_strptime&lt;/code&gt; は &lt;code&gt;Piece.xs&lt;/code&gt; で定義されていて、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xs&#34;&gt;void
_strftime(fmt, sec, min, hour, mday, mon, year, wday = -1, yday = -1, isdst = -1)
    char *        fmt
    int        sec
    int        min
    int        hour
    int        mday
    int        mon
    int        year
    int        wday
    int        yday
    int        isdst
    CODE:
    {
        char tmpbuf[128];
        struct tm mytm;
        int len;
        memset(&amp;amp;mytm, 0, sizeof(mytm));
        my_init_tm(&amp;amp;mytm);    /* XXX workaround - see my_init_tm() above */
        mytm.tm_sec = sec;
        mytm.tm_min = min;
        mytm.tm_hour = hour;
        mytm.tm_mday = mday;
        mytm.tm_mon = mon;
        mytm.tm_year = year;
        mytm.tm_wday = wday;
        mytm.tm_yday = yday;
        mytm.tm_isdst = isdst;
        my_mini_mktime(&amp;amp;mytm);
        len = strftime(tmpbuf, sizeof tmpbuf, fmt, &amp;amp;mytm);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっているが、どうやら &lt;code&gt;my_init_tm&lt;/code&gt; （この関数は Perl 5.8.0 以降では Perl 本体の &lt;code&gt;util.c&lt;/code&gt; に定義されている &lt;code&gt;init_tm&lt;/code&gt; のエイリアスになっている）でローカルタイムとして定義した後、 C 標準関数の &lt;code&gt;strftime&lt;/code&gt; を呼び出しており、そこで &lt;code&gt;%z&lt;/code&gt; は実行環境のタイムゾーンである &lt;code&gt;+0900&lt;/code&gt; を返してくることになる。つまり、 &lt;code&gt;GMT&lt;/code&gt; の時刻 + 実行環境のタイムゾーンが生成されていて、これがおかしな表示の理由ということになる。&lt;/p&gt;

&lt;h3 id=&#34;gmtime-を-localtime-に変換する:f982ae70135bfa8403b8ce10daa2a9de&#34;&gt;gmtime を localtime に変換する&lt;/h3&gt;

&lt;p&gt;ここまでの結果からズレを直すには&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;時刻はそのまま、タイムゾーンとして &lt;code&gt;GMT&lt;/code&gt;, &lt;code&gt;UTC&lt;/code&gt;, &lt;code&gt;+0000&lt;/code&gt; が返ってくるようにする&lt;/li&gt;
&lt;li&gt;タイムゾーンはそのまま、時刻をローカルタイムに変換する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;のどちらかを取ればよさそうだということがわかった。前者については GitHub に Time::Piece への &lt;a href=&#34;https://github.com/rjbs/Time-Piece/pull/3&#34;&gt;Pull Request&lt;/a&gt; があって、これがマージされれば解消できるように見える。ここでは後者について考えたい。&lt;/p&gt;

&lt;p&gt;まず、単純に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;my $format = &#39;%a, %e %b %Y %T %z&#39;;
my $datetime = &amp;quot;Tue, 14 Oct 2014 18:23:53 +0900&amp;quot;;
my $t = localtime(Time::Piece-&amp;gt;strptime($datetime, $format));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてみたが、これはうまくいかなかった。 &lt;code&gt;Piece.pm&lt;/code&gt; を見ると&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;sub localtime {
    unshift @_, __PACKAGE__ unless eval { $_[0]-&amp;gt;isa(&#39;Time::Piece&#39;) };
    my $class = shift;
    my $time  = shift;
    $time = time if (!defined $time);
    $class-&amp;gt;_mktime($time, 1);
}

sub _mktime {
    my ($class, $time, $islocal) = @_;
    $class = eval { (ref $class) &amp;amp;&amp;amp; (ref $class)-&amp;gt;isa(&#39;Time::Piece&#39;) }
           ? ref $class
           : $class;
    if (ref($time)) {
        $time-&amp;gt;[c_epoch] = undef;
        return wantarray ? @$time : bless [@$time[0..9], $islocal], $class;
    }
    _tzset();
    my @time = $islocal ?
            CORE::localtime($time)
                :
            CORE::gmtime($time);
    wantarray ? @time : bless [@time, $time, $islocal], $class;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となっていて、 &lt;code&gt;$time&lt;/code&gt; が Time::Piece オブジェクトの場合、 &lt;code&gt;$islocal&lt;/code&gt; フラグを立てて単に中身をコピーしてるだけ、ということなので、これだと時刻のズレはそのままフラグが立ってしまうという結果になる。これを回避するためには、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;my $format = &#39;%a, %e %b %Y %T %z&#39;;
my $datetime = &amp;quot;Tue, 14 Oct 2014 18:23:53 +0900&amp;quot;;
my $t = localtime(Time::Piece-&amp;gt;strptime($datetime, $format)-&amp;gt;epoch);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてエポックタイムを渡すようにし、 &lt;code&gt;_mktime&lt;/code&gt; の &lt;code&gt;CORE::localtime($time)&lt;/code&gt; を通るようにしてやればよい。結果、前述の回避策、ということになる&lt;/p&gt;

&lt;h2 id=&#34;まとめ:f982ae70135bfa8403b8ce10daa2a9de&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;一つ一つ Time::Piece のコードを読んでいった結果、なんとか当初の目的は達成できた。が、標準モジュールとして入っている割には Time::Piece は細かな挙動が読めなくて使うのが難しいなとは感じた&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go の Vim プラグインを vim-go に切り替えた</title>
      <link>http://tatsushid.github.io/blog/2014/10/switch-from-official-go-vim-plugin-to-vim-go/</link>
      <pubDate>Mon, 13 Oct 2014 13:59:29 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/10/switch-from-official-go-vim-plugin-to-vim-go/</guid>
      <description>&lt;p&gt;Vim で Go のコードを書いていて、エディタ内からお手軽にカバレッジ取れたらいいなと思って調べていたら、オフィシャルの Go の Vim プラグインではなく &lt;a href=&#34;https://github.com/fatih/vim-go&#34;&gt;vim-go&lt;/a&gt; を使えばできそうだということがわかったので、切り替えることにした&lt;/p&gt;

&lt;p&gt;まずは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;&amp;quot; Set golang vim scripts
exe &#39;set runtimepath+=&#39;.substitute(system(&#39;brew --prefix go&#39;), &#39;\n&#39;, &#39;&#39;, &#39;g&#39;).&#39;/libexec/misc/vim&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として読み込んでいたオフィシャルプラグインを外して、自分の環境ではプラグイン管理に &lt;a href=&#34;https://github.com/Shougo/neobundle.vim&#34;&gt;NeoBundle&lt;/a&gt; を使っているので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;NeoBundleLazy &#39;fatih/vim-go&#39;, {
       \ &#39;depends&#39; : &#39;majutsushi/tagbar&#39;,
       \ &#39;autoload&#39; : {
       \   &#39;filetypes&#39; : &#39;go&#39;,
       \   &#39;commands&#39; : [&#39;GoInstallBinaries&#39;, &#39;GoUpdateBinaries&#39;],
       \ }}

&amp;quot; vim-go &amp;quot;{{{
let bundle = neobundle#get(&#39;vim-go&#39;)
function! bundle.hooks.on_source(bundle)
       let g:go_fmt_autosave = 0
       let g:go_fmt_fail_silently = 1
endfunction
&amp;quot;}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように設定してみた。 &lt;a href=&#34;http://majutsushi.github.io/tagbar/&#34;&gt;Tagbar&lt;/a&gt; を使っている場合は &lt;code&gt;depends&lt;/code&gt; に一緒に読み込む設定を書いておくことで、 &lt;a href=&#34;https://github.com/jstemmer/gotags&#34;&gt;gotags&lt;/a&gt; を使ったアウトライン表示ができる。また、当初の目的だったカバレッジ取得は、 &lt;code&gt;:GoCoverage&lt;/code&gt; を実行すれば自動的にウェブブラウザが開いて結果を表示してくれるようになっている&lt;/p&gt;

&lt;p&gt;他にも支援プログラムを使った各種機能が盛りだくさんで、仮にそれらに必要なソフトウェアがインストールされていない場合は &lt;code&gt;:GoInstallBinaries&lt;/code&gt; を実行すれば、内部的に &lt;code&gt;go get&lt;/code&gt; して必要なパッケージを拾ってきてインストールしてくれる。それらの一括更新も &lt;code&gt;:GoUpdateBinaries&lt;/code&gt; で実行できて便利&lt;/p&gt;

&lt;p&gt;これでちょっとばかり Go を書く環境がリッチになったので、しばらく使い込んでみたい&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CentOS 3 の Docker イメージを作ってみた</title>
      <link>http://tatsushid.github.io/blog/2014/10/how-to-build-centos3-docker-image/</link>
      <pubDate>Sat, 04 Oct 2014 14:34:47 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/10/how-to-build-centos3-docker-image/</guid>
      <description>

&lt;p&gt;先日の Bash 脆弱性騒ぎに関連して、ごく一部で残ってる RHEL3 系のマシンにも Bash のパッチを当てざるを得ない状況が発生したため、この際パッケージビルド用の Docker イメージも作っておくか、ということでやってみた&lt;/p&gt;

&lt;h2 id=&#34;必要なもの:0f9548c31060b9cf09120147eb98969b&#34;&gt;必要なもの&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;CentOS 3 がインストールされているサーバないし仮想マシン&lt;/li&gt;
&lt;li&gt;Yum パッケージ&lt;/li&gt;
&lt;li&gt;CentOS 3 のパッケージが含まれているリポジトリへのアクセス&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CentOS 3 のマシンは楽にやるには必須だと思う。初めは CentOS 6 上でやってみたが、後述のスクリプト実行時に最新の CentOS 6 のパッケージを拾ってこようとするのをうまく回避できなかったので、結局 CentOS 3 上で作業を行った&lt;/p&gt;

&lt;h2 id=&#34;作成の流れ:0f9548c31060b9cf09120147eb98969b&#34;&gt;作成の流れ&lt;/h2&gt;

&lt;p&gt;といっても、ほとんどやることはなくて、だいたい以下に集約される&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yum.conf&lt;/code&gt; を編集して CentOS 3 パッケージが含まれているリポジトリを参照するようにする&lt;/li&gt;
&lt;li&gt;Docker プロジェクトが提供している &lt;a href=&#34;https://github.com/docker/docker/blob/master/contrib/mkimage-yum.sh&#34;&gt;mkimage-yum.sh&lt;/a&gt; を持ってきて、 CentOS 3 向けにカスタマイズする&lt;/li&gt;
&lt;li&gt;スクリプト実行して &lt;code&gt;os_image.tar.gz&lt;/code&gt; を得る&lt;/li&gt;
&lt;li&gt;できた &lt;code&gt;os_image.tar.gz&lt;/code&gt; を Docker に食わせてイメージ化する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下、個々の作業の説明&lt;/p&gt;

&lt;h3 id=&#34;yum-conf-の編集:0f9548c31060b9cf09120147eb98969b&#34;&gt;yum.conf の編集&lt;/h3&gt;

&lt;p&gt;サーバ内に Yum が入っていなければ、まずはこれが必須なので入れておくのだが、 CentOS 3 はもうメンテされていないので、パッケージを拾ってこれるミラーサーバを &lt;code&gt;yum.conf&lt;/code&gt; に設定しておかなければならない。普通は &lt;code&gt;http://vault.centos.org/&lt;/code&gt; を設定しておけばいいと思うが、当たるミラーによってはかなり遅いことになるので、場合によっては速度の出るミラーサーバの IP アドレスを &lt;code&gt;dig&lt;/code&gt; なりなんなりで調べて直接 IP アドレスを指定しておく必要があるかもしれない。具体的な変更は &lt;code&gt;yum.conf&lt;/code&gt; 内にいくつかある&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいな行を&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;baseurl=http://vault.centos.org/3.9/os/i386/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように書き換えておくだけである&lt;/p&gt;

&lt;h3 id=&#34;mkimage-yum-sh-のカスタマイズ:0f9548c31060b9cf09120147eb98969b&#34;&gt;mkimage-yum.sh のカスタマイズ&lt;/h3&gt;

&lt;p&gt;一番手間取ったのがここだったが、わかってしまえばなんということもない内容。書き換えたスクリプトはこんな感じ&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/tatsushid/22d169ea1e91e8941773.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;はまったポイントは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mktemp が古いためにオプションの扱いが違う。最初気付かずやって、それなりの量のシステムファイルを消してしまった…&lt;/li&gt;
&lt;li&gt;パッケージを検証する GPG KEY を Yum が勝手には拾ってきてくれないので、自分で先に対象ディレクトリに落としておく&lt;/li&gt;
&lt;li&gt;なぜか Docker にインポートした後 RPM DB が壊れているようだったので、 &lt;code&gt;yum clean&lt;/code&gt; 後に &lt;code&gt;rpm --rebuilddb&lt;/code&gt; を実行しておく&lt;/li&gt;
&lt;li&gt;ldconfig キャッシュは消してもいいが、できたイメージをすぐ使いたい時は、ライブラリが見つからなくていちいち再構築も面倒なので、残しておく&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といったところ&lt;/p&gt;

&lt;h3 id=&#34;スクリプトの実行:0f9548c31060b9cf09120147eb98969b&#34;&gt;スクリプトの実行&lt;/h3&gt;

&lt;p&gt;これはそのまんま、上記で作成しておいた &lt;code&gt;yum.conf&lt;/code&gt; を &lt;code&gt;mkimage-yum.sh&lt;/code&gt; に指定して実行するだけである。うまくいけば &lt;code&gt;os_image.tar.gz&lt;/code&gt; がカレントディレクトリ内に作られる&lt;/p&gt;

&lt;h3 id=&#34;docker-でイメージ化:0f9548c31060b9cf09120147eb98969b&#34;&gt;Docker でイメージ化&lt;/h3&gt;

&lt;p&gt;できた &lt;code&gt;os_image.tar.gz&lt;/code&gt; を Docker が動いている環境に持ってきて、下記のようにコマンドを実行する&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat os_image.tar.gz | docker import - centos-3-i386
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;centos-3-i386&lt;/code&gt; の部分はイメージ名になるので、好きなように設定すればよい。インポートに成功したら、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -i -t centos-3-i386 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにして使い始めることができる&lt;/p&gt;

&lt;h2 id=&#34;まとめ:0f9548c31060b9cf09120147eb98969b&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;上記の流れでできたイメージを使って、無事パッチ済みの Bash の RPM の作成もできたので、日常の作業には十分な環境が作成できたと思う&lt;/p&gt;

&lt;p&gt;Docker のイメージを作ったのは初めてだったが、 OS が稼働するのに必要なファイル群を tar に固めて食わせるだけ、というのは手軽でいい。各種ディストリビューションごとにマイクロ環境を作れるようなツールがあったりするので、それを使えば気楽にイメージが作れるだろうな、と思う&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HAProxy でのソース IP アドレスアフィニティ設定方法</title>
      <link>http://tatsushid.github.io/blog/2014/09/source-ip-address-affinty-configuration-in-haproxy/</link>
      <pubDate>Mon, 29 Sep 2014 22:11:18 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/09/source-ip-address-affinty-configuration-in-haproxy/</guid>
      <description>

&lt;p&gt;HAProxy で、アクセス元のクライアントの IP アドレスを元に、分散先サーバを固定したい場合、 &lt;code&gt;backend&lt;/code&gt; または &lt;code&gt;listen&lt;/code&gt; セクションで次のように設定すればよい&lt;/p&gt;

&lt;h2 id=&#34;frontend-と-backend-を分けて設定してる場合:91b8713e75d1ee54903a1ba0ef999c8b&#34;&gt;frontend と backend を分けて設定してる場合&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;frontend web-front
	bind *:80
	default_backend web-back

backend web-back
	balance source # Affinity setting
	server s1 192.168.1.11:80 check
	server s2 192.168.1.12:80 check
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;listen-でまとめて設定している場合:91b8713e75d1ee54903a1ba0ef999c8b&#34;&gt;listen でまとめて設定している場合&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;listen web
	bind *:80
	balance source # Affinity setting
	server s1 192.168.1.11:80 check
	server s2 192.168.1.12:80 check
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡単な設定の割にはドキュメントを探すのに結構苦労した&lt;/p&gt;

&lt;h2 id=&#34;参考にしたページ:91b8713e75d1ee54903a1ba0ef999c8b&#34;&gt;参考にしたページ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.haproxy.com/2012/03/29/load-balancing-affinity-persistence-sticky-sessions-what-you-need-to-know/&#34;&gt;load balancing, affinity, persistence, sticky sessions: what you need to know&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cbonte.github.io/haproxy-dconv/configuration-1.5.html#4-balance&#34;&gt;HAProxy Configuration Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Go の構造体とポインタと omitempty の話</title>
      <link>http://tatsushid.github.io/blog/2014/09/go-structure-pointer-and-omitempty/</link>
      <pubDate>Tue, 23 Sep 2014 06:42:55 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/09/go-structure-pointer-and-omitempty/</guid>
      <description>

&lt;p&gt;（下記は go 1.3.1 での話で、異なるバージョンだと動作も違う可能性があるので注意）&lt;/p&gt;

&lt;h2 id=&#34;結論:5bfb78d2fd527d70f781ba5f5e936dd8&#34;&gt;結論&lt;/h2&gt;

&lt;p&gt;Go で &lt;code&gt;encoding/xml&lt;/code&gt; を使って XML のエンコーディングを行っている時に、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ある特定のタグの子要素ないし属性が一つでもある場合は、そのタグを出力する&lt;/li&gt;
&lt;li&gt;上記のいずれもない場合は、タグは出力しない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を実現したい場合は、単純に要素のポインタ型を使って &lt;code&gt;omitempty&lt;/code&gt; は使わないのが正解&lt;/p&gt;

&lt;h2 id=&#34;詳細:5bfb78d2fd527d70f781ba5f5e936dd8&#34;&gt;詳細&lt;/h2&gt;

&lt;p&gt;上記のケースを最初は単純に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/xml&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
)

type Foo struct {
	Str string
}

type Bar struct {
	Foo Foo `xml:&amp;quot;,omitempty&amp;quot;`
}

func main() {
	bar := Bar{} // Foo は空
	b, err := xml.MarshalIndent(bar, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b)) // &amp;lt;Bar&amp;gt;&amp;lt;/Bar&amp;gt; と出力されてほしい
	// Output:
	// &amp;lt;Bar&amp;gt;
	//   &amp;lt;Foo&amp;gt;
	//     &amp;lt;Str&amp;gt;&amp;lt;/Str&amp;gt;
	//   &amp;lt;/Foo&amp;gt;
	// &amp;lt;/Bar&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてみたのだけど、うまくいかなかった。理由は &lt;a href=&#34;http://golang.org/pkg/encoding/xml/&#34;&gt;encoding/xml&lt;/a&gt; のドキュメントによると&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;a field with a tag including the &amp;ldquo;omitempty&amp;rdquo; option is omitted
if the field value is empty. The empty values are false, 0, any
nil pointer or interface value, and any array, slice, map, or
string of length zero.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;ということで、空の構造体と比較してはくれないためのよう。ここで対象が &lt;code&gt;nil&lt;/code&gt; ポインタなら空と扱う、と書いてあるので、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/xml&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
)

type Foo struct {
	Str string
}

type Bar struct {
	Foo *Foo `xml:&amp;quot;,omitempty&amp;quot;` // omitempty はあってもなくてもよい
}

func main() {
	bar := Bar{} // Foo は nil
	b, err := xml.MarshalIndent(bar, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b)) // &amp;lt;Bar&amp;gt;&amp;lt;/Bar&amp;gt; と出力されてほしい
	// Output:
	// &amp;lt;Bar&amp;gt;&amp;lt;/Bar&amp;gt;

	bar.Foo = new(Foo)
	b, err := xml.MarshalIndent(bar, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &amp;lt;Bar&amp;gt;
	//   &amp;lt;Foo&amp;gt;
	//     &amp;lt;Str&amp;gt;&amp;lt;/Str&amp;gt;
	//   &amp;lt;/Foo&amp;gt;
	// &amp;lt;/Bar&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と、 &lt;code&gt;Foo&lt;/code&gt; のポインタを構造体に含めるようにしてみるとうまく動く。もちろん要素がある場合も問題なく動く。さらに、この場合は別に &lt;code&gt;omitempty&lt;/code&gt; なしでも意図通りの動作になる&lt;/p&gt;

&lt;p&gt;ところが、たとえば構造体の要素が &lt;code&gt;int&lt;/code&gt; で、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt; の要素が 0 である場合は、要素があるとみなして出力する（つまり &lt;code&gt;omitempty&lt;/code&gt; を無視する）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt; の要素そのものが存在しない時は出力しない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の場合は、同じようにやっても期待通りにはならない。 &lt;code&gt;int&lt;/code&gt; が 0 の場合は &lt;code&gt;omitempty&lt;/code&gt; の対象として扱ってしまう&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/xml&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
)

type Foo struct {
	Bar *int `xml:&amp;quot;,omitempty&amp;quot;`
}

func main() {
	foo := Foo{}
	b, err := xml.MarshalIndent(foo, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &amp;lt;Foo&amp;gt;&amp;lt;/Foo&amp;gt;

	foo.Bar = new(int)
	*(foo.Bar) = 0
	b, err = xml.MarshalIndent(foo, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &amp;lt;Foo&amp;gt;&amp;lt;/Foo&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合は、要素の型をポインタ型にしつつ、素直に &lt;code&gt;omitempty&lt;/code&gt; を外すか、ポインタのポインタを使うと意図通りの結果が得られるようだ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/xml&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
)

type Foo struct {
	Bar *int
	Baz **int `xml:&amp;quot;,omitempty&amp;quot;`
}

func main() {
	foo := Foo{}
	b, err := xml.MarshalIndent(foo, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &amp;lt;Foo&amp;gt;&amp;lt;/Foo&amp;gt;

	foo.Bar = new(int)
	*(foo.Bar) = 0
	tmp := new(int)
	*tmp = 0
	foo.Baz = &amp;amp;tmp
	b, err = xml.MarshalIndent(foo, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &amp;lt;Foo&amp;gt;
	//   &amp;lt;Bar&amp;gt;0&amp;lt;/Bar&amp;gt;
	//   &amp;lt;Baz&amp;gt;0&amp;lt;/Baz&amp;gt;
	// &amp;lt;/Foo&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いろいろとややこしい&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go でインターフェース型の reflect.Type を取得する方法</title>
      <link>http://tatsushid.github.io/blog/2014/09/how-to-get-reflect-type-of-interface-type-in-go/</link>
      <pubDate>Fri, 19 Sep 2014 21:46:21 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/09/how-to-get-reflect-type-of-interface-type-in-go/</guid>
      <description>&lt;p&gt;Go の &lt;code&gt;reflect&lt;/code&gt; パッケージを使っていて、ときどき操作している変数型との比較のために &lt;code&gt;error&lt;/code&gt; などのインターフェース型の &lt;code&gt;reflect.Type&lt;/code&gt; がほしいことがあるのだけれど、これは &lt;code&gt;reflect.TypeOf((*error)(nil)).Elem()&lt;/code&gt; のように書くことで得られる。つまり、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nil&lt;/code&gt; をほしい型のポインタ型に変換&lt;/li&gt;
&lt;li&gt;それを &lt;code&gt;reflect.TypeOf&lt;/code&gt; に渡してポインタ型の &lt;code&gt;reflect.Type&lt;/code&gt; を取得し&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Elem()&lt;/code&gt; でポインタをデリファレンスしてできる基本型の &lt;code&gt;reflect.Type&lt;/code&gt; を得る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という流れ。 Go の公式パッケージではよく見かける書法。これを使うと、たとえば変数が &lt;code&gt;error&lt;/code&gt; インターフェースを満たすかどうかの判定は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
        &amp;quot;errors&amp;quot;
        &amp;quot;fmt&amp;quot;
        &amp;quot;reflect&amp;quot;
)

func main() {
	err := errors.New(&amp;quot;A problem occurs&amp;quot;)
	et := reflect.TypeOf(err)
	if et.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
		fmt.Println(&amp;quot;This is an error type&amp;quot;)
	} else {
		fmt.Println(&amp;quot;This isn&#39;t an error type&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように書ける。もちろん、これはリフレクションを操作してる時の話で、普通は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
        &amp;quot;errors&amp;quot;
        &amp;quot;fmt&amp;quot;
)

func main() {
	err := errors.New(&amp;quot;A problem occurs&amp;quot;)
	if _, ok := err.(error); ok {
		fmt.Println(&amp;quot;This is an error type&amp;quot;)
	} else {
		fmt.Println(&amp;quot;This isn&#39;t an error type&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするのがよい&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CentOSのyumミラーリストの調べ方</title>
      <link>http://tatsushid.github.io/blog/2014/09/how-to-check-centos-mirrorlist/</link>
      <pubDate>Thu, 18 Sep 2014 22:10:41 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/09/how-to-check-centos-mirrorlist/</guid>
      <description>&lt;p&gt;ここ最近 CentOS の yum で updates からパッケージを持ってくる時の速度がやけに遅いので、 yum にはどんなミラーが返ってきてるのか調べてみた。 yum は 64bit 環境で特別設定を変えてなければ、通常 &lt;code&gt;http://mirrorlist.centos.org/?release=6&amp;amp;arch=x86_64&amp;amp;repo=os&lt;/code&gt; や &lt;code&gt;http://mirrorlist.centos.org/?release=6&amp;amp;arch=x86_64&amp;amp;repo=updates&lt;/code&gt; にアクセスしているので、この URL にブラウザでアクセスするか、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl &#39;http://mirrorlist.centos.org/?release=6&amp;amp;arch=x86_64&amp;amp;repo=os&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように &lt;code&gt;curl&lt;/code&gt; を使えば、ミラーの一覧が返る。 &lt;code&gt;release&lt;/code&gt; は CentOS のメジャーバージョン、 &lt;code&gt;arch&lt;/code&gt; は &lt;code&gt;i386&lt;/code&gt; や &lt;code&gt;x86_64&lt;/code&gt; などのアーキテクチャ、 &lt;code&gt;repo&lt;/code&gt; はリポジトリの種類をそれぞれ指定できる。さらに、 URL に &lt;code&gt;cc=jp&lt;/code&gt; や &lt;code&gt;ip=8.8.8.8&lt;/code&gt; などのクエリを追加すると、国コード別、 IP アドレス別のミラーリストを返してくれるらしい。たとえば、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl &#39;http://mirrorlist.centos.org/?release=6&amp;amp;arch=x86_64&amp;amp;repo=os&amp;amp;cc=jp&#39; # 国コード別
curl &#39;http://mirrorlist.centos.org/?release=6&amp;amp;arch=x86_64&amp;amp;repo=os&amp;amp;ip=8.8.8.8&#39; # IP アドレス別
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとすると、それぞれの結果が返る。なお、今日の時点 (2014-09-18) で os の方は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://ftp.nara.wide.ad.jp/pub/Linux/centos/6.5/os/x86_64/
http://ftp.tsukuba.wide.ad.jp/Linux/centos/6.5/os/x86_64/
http://ftp.iij.ad.jp/pub/linux/centos/6.5/os/x86_64/
http://ftp.jaist.ac.jp/pub/Linux/CentOS/6.5/os/x86_64/
http://ftp.riken.jp/Linux/centos/6.5/os/x86_64/
http://www.ftp.ne.jp/Linux/packages/CentOS/6.5/os/x86_64/
http://mirror.fairway.ne.jp/centos/6.5/os/x86_64/
http://mirror.vodien.com/centos/6.5/os/x86_64/
http://mirror.nus.edu.sg/centos/6.5/os/x86_64/
http://centos.mirror.secureax.com/6.5/os/x86_64/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のような結果が返ってくるが、 updates の方はなぜか&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://mirrors.hust.edu.cn/centos/6.5/updates/x86_64/
http://mirrors.yun-idc.com/centos/6.5/updates/x86_64/
http://centos.mirror.cdnetworks.com/6.5/updates/x86_64/
http://ftp.yzu.edu.tw/Linux/CentOS/6.5/updates/x86_64/
http://ftp.isu.edu.tw/pub/Linux/CentOS/6.5/updates/x86_64/
http://mirror.awanti.com/centos/6.5/updates/x86_64/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようなリストを返してきてて、国内ミラーを使ってくれてないのが速度が出てない理由なのかな、と&lt;/p&gt;

&lt;p&gt;余談だけど、各国のミラーの状態は &lt;a href=&#34;http://mirror-status.centos.org/&#34;&gt;http://mirror-status.centos.org/&lt;/a&gt; で見れる&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>静的サイトジェネレーターを Hugo に切り替えた</title>
      <link>http://tatsushid.github.io/blog/2014/08/change-site-generator-to-hugo/</link>
      <pubDate>Sat, 16 Aug 2014 14:00:00 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/08/change-site-generator-to-hugo/</guid>
      <description>&lt;p&gt;ここ半年から一年の間、ちょっとしたコマンドラインツールの開発にはずっと golang を使ってきてて、せっかくなのでサイトジェネレーターもこの際 golang 製に変えてみようということで、 &lt;a href=&#34;http://hugo.spf13.com/&#34;&gt;Hugo&lt;/a&gt; を使ってみることにした。今のところの使用感としては、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;バイナリ拾ってくるだけなのでインストール簡単&lt;/li&gt;
&lt;li&gt;サイト生成速度が速い！&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt; と同様に Front Matter がある（各ページのメタデータを定義できるもの）&lt;/li&gt;
&lt;li&gt;他のツールにもあるが、ローカルサーバでのプレビュー機能便利&lt;/li&gt;
&lt;li&gt;他のツールほどメジャーではないせいか、既成のテンプレートが少ない (´；ω；｀)&lt;/li&gt;
&lt;li&gt;Go 標準のテンプレートパッケージ使ってるためか、テンプレートでいろいろやろうとすると制約が厳しい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といったところ。 golang の特質はそのままのため、がんばって言語環境整備しなくても、 Windows とか他のプラットフォームでも同じように使えるのはいいところだと思う。コード量もそれほどではないので、自分で機能を追加するのもそれほど難しくない&lt;/p&gt;

&lt;p&gt;一方でテンプレートは本当に選択肢が少なすぎるので、勉強も兼ねて、 &lt;a href=&#34;http://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt; 用のテーマの &lt;a href=&#34;http://lanyon.getpoole.com/&#34;&gt;Lanyon&lt;/a&gt; を移植して、それにちょっとだけ手を加えたものを使うことにした。こちらは気が向いたら公開したい&lt;/p&gt;

&lt;p&gt;このテンプレートを作っていてわかったのは、 golang 標準の text/template と派生の html/template のテンプレートパッケージでは、書式自体は分かりやすくていいものの、制御構文が少なかったり定義した変数のスコープの絡みとかでいろいろと制約があり、プログラム側に手を入れて補助関数を作らないと、単純なものでも機能実現できないものが多々あるなあというところ。この辺りは、ロジックはあくまでプログラム側で処理し、テンプレートはそれを表示するだけだ、という考え方でできているのだと思うが、ちょっとしたカスタマイズでプログラム自体に手を入れなければいけないのは、メンテナンスの面でちょっとつらい。柔軟性の高い補助関数とかが Hugo 本家に入るのを見ていくしかないのかな、という気もする&lt;/p&gt;

&lt;p&gt;ともあれ、 Hugo 自体は必要十分な機能がよくまとまっていて、何よりサイト生成が早いこともあって、気軽に何度でもトライアンドエラーを繰り返して試せるので、個人的には気に入っている。しばらくいろいろ試してみたいと思う&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>wgetでの保存先ディレクトリを指定する</title>
      <link>http://tatsushid.github.io/blog/2014/08/specify-wget-savedir/</link>
      <pubDate>Mon, 11 Aug 2014 16:54:00 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/08/specify-wget-savedir/</guid>
      <description>&lt;p&gt;wget コマンドを使っていると、たまにカレントディレクトリではなくて他の場所にデータを保存したい時があるのだけれど、その方法をしばしば忘れるのでメモ。これをやりたい時は、 -P オプションを使えばよい。たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget -P path/to/dstdir http://localhost/path/to/srcfile.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の様に実行すると、 &lt;code&gt;path/to/dstdir/srcfile.tar.gz&lt;/code&gt; の様に保存される&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CentOS7をGPTパーティションで新規インストールする</title>
      <link>http://tatsushid.github.io/blog/2014/07/install-centos7-on-gpt-drive/</link>
      <pubDate>Fri, 25 Jul 2014 13:04:00 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/07/install-centos7-on-gpt-drive/</guid>
      <description>&lt;p&gt;CentOS 7 を GPT パーティションでインストールするのは難しくない。 &lt;a href=&#34;https://bugzilla.redhat.com/show_bug.cgi?id=1032428&#34;&gt;Bug 1032428 - Need a 1MB &amp;lsquo;biosboot&amp;rsquo; type partition when install RHEL7 on a GPT disk with custom partition&lt;/a&gt; によると、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2TB 未満のディスクを使用すると自動的に MSDOS パーティションを使用&lt;/li&gt;
&lt;li&gt;2TB 以上のディスクを使用すると自動的に GPT パーティションを使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という形となっているため、通常は意識して選択する必要がない。また、 2TB 未満のディスクも GPT パーティションとしてインストールしたければ、インストール CD からインストーラーをブートする時のカーネルオプションに inst.gpt を指定しておくと、ディスク種別にかかわらず GTP パーティションが使われるようになる&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CentOS5をGPTパーティションで新規インストールする</title>
      <link>http://tatsushid.github.io/blog/2014/07/install-centos5-on-gpt-drive/</link>
      <pubDate>Tue, 08 Jul 2014 20:06:00 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/07/install-centos5-on-gpt-drive/</guid>
      <description>&lt;p&gt;CentOS 5 の新規インストール時に GPT パーティションを使いたい場合は、 CentOS 6 の様に一筋縄では行かない。今回は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.endpoint.com/2013/11/installing-centos-5-on-3tb-drive.html&#34;&gt;Installing CentOS 5 on a 3 TB Drive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.tkr.mydns.jp/index.php?title=Linux関連/CentOS5_GPT_対応インストール手順&#34;&gt;CentOS5 GPT 対応インストール手順&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を参考に、下記のような手順で仮想マシン作成作業を行ってみた&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ネットワークインストール用の ISO イメージをダウンロードし、仮想マシンに CD イメージとして読み込ませる設定を行う&lt;/li&gt;
&lt;li&gt;起動選択画面で &lt;code&gt;linux resque&lt;/code&gt; と入力し、レスキューモードでサーバを起動する&lt;/li&gt;
&lt;li&gt;起動後は言語選択、キーボード設定、ネットワーク設定、レスキューモード用イメージのダウンロード先を指定して進める。既存 OS 選択画面では Skip を選択して進める&lt;/li&gt;

&lt;li&gt;&lt;p&gt;レスキューモードのシェルが立ち上がるので、下記のようにコマンドを実行してディスクのパーティションを切る&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;parted /dev/sda
(parted) mklabel gpt
(parted) mkpart primary ext3 0 200MB
(parted) mkpart primary linux-swap 200MB 2248MB
(parted) mkpart primary ext3 2248MB 21.5GB
(parted) set 1 boot on
(parted) quit
mkfs.ext3 /dev/sda1
mkfs.ext3 /dev/sda3
mkswap /dev/sda2
tune2fs -c 0 -i 0 /dev/sda1
tune2fs -c 0 -i 0 /dev/sda3
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;そのままでは Anaconda のエラーメッセージが出てインストール処理を先に進められないので、 Anaconda を下記の手順で上書きする&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir /mnt/anaconda
mount -t tmpfs none /mnt/anaconda
cd /mnt/anaconda
tar -cpf - -C /mnt/runtime/usr/lib/anaconda . | tar -xpf -
vi partitions.py # ここで 1082 行目の errors を warnings に書き換えて保存する
mount -o bind /mnt/anaconda /mnt/runtime/usr/lib/anaconda
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;このまま Anaconda を起動すると &lt;code&gt;/sbin&lt;/code&gt; が存在しているというエラーが出て起動できないため、下記の手順で空の &lt;code&gt;/sbin&lt;/code&gt; を用意する&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export PATH=$PATH:/sbin.bak
mv /sbin /sbin.bak
mkdir /sbin
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Anaconda の起動準備が完了したので、適切なミラーサイトの URL を使って Anaconda を起動する&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;anaconda --dmraid --selinux -T -m &amp;quot;http://ftp.iij.ad.jp/pub/linux/centos/5/os/x86_64/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;インストール処理は、ディスクのパーティション設定以外、いつもの通りに進める。パーティション設定の画面では、すでに作成されているパーティションにマウントポイントを割り当てるにとどめ。パーティションの再フォーマットなどは行わない。 GPT では起動できないとの警告が出たら、そのまま OK を押して進める&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;インストールが終わったら再起動を行うが、その前に、後の GRUB のインストール作業のために、 ISO イメージを CentOS 5 のものから CentOS 6 のものに差し替えておく&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;再起動を行う。そのまま再起動ボタンを押しても、 Anaconda が終了するだけで再起動処理が行われないので、 &lt;code&gt;Ctrl+Alt+Delete&lt;/code&gt; を入力するなどして再起動する&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CentOS 6 のディスクで起動してきたら、レスキューモードを選択して進める。言語選択、キーボード設定を行うが、ネットワーク設定は不要。既存 OS 選択画面では Skip を選択して進める&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;シェルが立ち上がったら下記の手順で &lt;code&gt;/boot&lt;/code&gt; パーティションをマウントし、必要な GRUB のファイルを上書きする&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir /boot
mount /dev/sda1 /boot
cp /usr/share/grub/x86_64-redhat/e2fs_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/fat_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/ffs_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/iso9660_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/jfs_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/minix_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/reiserfs_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/stage1 /boot/grub/
cp /usr/share/grub/x86_64-redhat/stage2 /boot/grub/
cp /usr/share/grub/x86_64-redhat/ufs2_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/vstafs_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/xfs_stage1_5 /boot/grub/
umount /boot
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ファイルを上書きしたら、 MBR へ GRUB をインストールする&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grub
grub&amp;gt; root (hd0,0)
grub&amp;gt; setup (hd0)
grub&amp;gt; quit
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GRUB のインストールが完了したら、 ISO イメージを取り出し、再起動を行う&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上の手順で、 GPT パーティションが有効な状態で、新規インストールした CentOS 5 が起動できた&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CentOS6をGPTパーティションで新規インストールする</title>
      <link>http://tatsushid.github.io/blog/2014/07/install-centos6-on-gpt-drive/</link>
      <pubDate>Mon, 07 Jul 2014 19:15:00 +0900</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/07/install-centos6-on-gpt-drive/</guid>
      <description>&lt;p&gt;毎度毎度コマンドの打ち方を忘れてしまうのでメモ。 RHEL 6 互換のディストリビューションを新規インストールする際、 GPT パーティションを使いたい場合は、インストーラーで適当なところ（パーティション設定の直前辺り）まで進めたところで下記のようにコマンドを実行すると、自分でパーティションを切ることができる&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Alt + Ctrl + F2&lt;/code&gt; でターミナルに切り替える&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parted /dev/sdx&lt;/code&gt; （ sdx は実際のデバイス名を指定）を実行する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mklabel gpt&lt;/code&gt; と入力して実行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;quit&lt;/code&gt; を入力して parted を抜ける&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Alt + F6&lt;/code&gt; でターミナルを抜ける&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上のように実行すると、ディスクデバイスに GPT パーティションが設定される。後は普通にパーティション設定を行ってインストールを進めていけば、 GPT パーティションのサーバができあがる&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>