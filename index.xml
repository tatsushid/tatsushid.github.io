<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Recent Content on tatsushid.github.io </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://tatsushid.github.io/index.xml/</link>
    <language>ja-jp</language>
    
    
    <updated>Mon, 13 Oct 2014 13:59:29 JST</updated>
    
    <item>
      <title>Go の Vim プラグインを vim-go に切り替えた</title>
      <link>http://tatsushid.github.io/blog/2014/10/switch-from-official-go-vim-plugin-to-vim-go/</link>
      <pubDate>Mon, 13 Oct 2014 13:59:29 JST</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/10/switch-from-official-go-vim-plugin-to-vim-go/</guid>
      <description>&lt;p&gt;Vim で Go のコードを書いていて、エディタ内からお手軽にカバレッジ取れたらいいなと思って調べていたら、オフィシャルの Go の Vim プラグインではなく &lt;a href=&#34;https://github.com/fatih/vim-go&#34;&gt;vim-go&lt;/a&gt; を使えばできそうだということがわかったので、切り替えることにした&lt;/p&gt;

&lt;p&gt;まずは&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;vim&#34;&gt;&amp;quot; Set golang vim scripts
exe &#39;set runtimepath+=&#39;.substitute(system(&#39;brew --prefix go&#39;), &#39;\n&#39;, &#39;&#39;, &#39;g&#39;).&#39;/libexec/misc/vim&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として読み込んでいたオフィシャルプラグインを外して、自分の環境ではプラグイン管理に &lt;a href=&#34;https://github.com/Shougo/neobundle.vim&#34;&gt;NeoBundle&lt;/a&gt; を使っているので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;vim&#34;&gt;NeoBundleLazy &#39;fatih/vim-go&#39;, {
       \ &#39;depends&#39; : &#39;majutsushi/tagbar&#39;,
       \ &#39;autoload&#39; : {
       \   &#39;filetypes&#39; : &#39;go&#39;,
       \   &#39;commands&#39; : [&#39;GoInstallBinaries&#39;, &#39;GoUpdateBinaries&#39;],
       \ }}

&amp;quot; vim-go &amp;quot;{{{
let bundle = neobundle#get(&#39;vim-go&#39;)
function! bundle.hooks.on_source(bundle)
       let g:go_fmt_autosave = 0
       let g:go_fmt_fail_silently = 1
endfunction
&amp;quot;}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように設定してみた。 &lt;a href=&#34;http://majutsushi.github.io/tagbar/&#34;&gt;Tagbar&lt;/a&gt; を使っている場合は &lt;code&gt;depends&lt;/code&gt; に一緒に読み込む設定を書いておくことで、 &lt;a href=&#34;https://github.com/jstemmer/gotags&#34;&gt;gotags&lt;/a&gt; を使ったアウトライン表示ができる。また、当初の目的だったカバレッジ取得は、 &lt;code&gt;:GoCoverage&lt;/code&gt; を実行すれば自動的にウェブブラウザが開いて結果を表示してくれるようになっている&lt;/p&gt;

&lt;p&gt;他にも支援プログラムを使った各種機能が盛りだくさんで、仮にそれらに必要なソフトウェアがインストールされていない場合は &lt;code&gt;:GoInstallBinaries&lt;/code&gt; を実行すれば、内部的に &lt;code&gt;go get&lt;/code&gt; して必要なパッケージを拾ってきてインストールしてくれる。それらの一括更新も &lt;code&gt;:GoUpdateBinaries&lt;/code&gt; で実行できて便利&lt;/p&gt;

&lt;p&gt;これでちょっとばかり Go を書く環境がリッチになったので、しばらく使い込んでみたい&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CentOS 3 の Docker イメージを作ってみた</title>
      <link>http://tatsushid.github.io/blog/2014/10/how-to-build-centos3-docker-image/</link>
      <pubDate>Sat, 04 Oct 2014 14:34:47 JST</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/10/how-to-build-centos3-docker-image/</guid>
      <description>

&lt;p&gt;先日の Bash 脆弱性騒ぎに関連して、ごく一部で残ってる RHEL3 系のマシンにも Bash のパッチを当てざるを得ない状況が発生したため、この際パッケージビルド用の Docker イメージも作っておくか、ということでやってみた&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;必要なもの&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;CentOS 3 がインストールされているサーバないし仮想マシン&lt;/li&gt;
&lt;li&gt;Yum パッケージ&lt;/li&gt;
&lt;li&gt;CentOS 3 のパッケージが含まれているリポジトリへのアクセス&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CentOS 3 のマシンは楽にやるには必須だと思う。初めは CentOS 6 上でやってみたが、後述のスクリプト実行時に最新の CentOS 6 のパッケージを拾ってこようとするのをうまく回避できなかったので、結局 CentOS 3 上で作業を行った&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;作成の流れ&lt;/h2&gt;

&lt;p&gt;といっても、ほとんどやることはなくて、だいたい以下に集約される&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yum.conf&lt;/code&gt; を編集して CentOS 3 パッケージが含まれているリポジトリを参照するようにする&lt;/li&gt;
&lt;li&gt;Docker プロジェクトが提供している &lt;a href=&#34;https://github.com/docker/docker/blob/master/contrib/mkimage-yum.sh&#34;&gt;mkimage-yum.sh&lt;/a&gt; を持ってきて、 CentOS 3 向けにカスタマイズする&lt;/li&gt;
&lt;li&gt;スクリプト実行して &lt;code&gt;os_image.tar.gz&lt;/code&gt; を得る&lt;/li&gt;
&lt;li&gt;できた &lt;code&gt;os_image.tar.gz&lt;/code&gt; を Docker に食わせてイメージ化する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下、個々の作業の説明&lt;/p&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;yum.conf の編集&lt;/h3&gt;

&lt;p&gt;サーバ内に Yum が入っていなければ、まずはこれが必須なので入れておくのだが、 CentOS 3 はもうメンテされていないので、パッケージを拾ってこれるミラーサーバを &lt;code&gt;yum.conf&lt;/code&gt; に設定しておかなければならない。普通は &lt;code&gt;http://vault.centos.org/&lt;/code&gt; を設定しておけばいいと思うが、当たるミラーによってはかなり遅いことになるので、場合によっては速度の出るミラーサーバの IP アドレスを &lt;code&gt;dig&lt;/code&gt; なりなんなりで調べて直接 IP アドレスを指定しておく必要があるかもしれない。具体的な変更は &lt;code&gt;yum.conf&lt;/code&gt; 内にいくつかある&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいな行を&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;baseurl=http://vault.centos.org/3.9/os/i386/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように書き換えておくだけである&lt;/p&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;mkimage-yum.sh のカスタマイズ&lt;/h3&gt;

&lt;p&gt;一番手間取ったのがここだったが、わかってしまえばなんということもない内容。書き換えたスクリプトはこんな感じ&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/tatsushid/22d169ea1e91e8941773.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;はまったポイントは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mktemp が古いためにオプションの扱いが違う。最初気付かずやって、それなりの量のシステムファイルを消してしまった…&lt;/li&gt;
&lt;li&gt;パッケージを検証する GPG KEY を Yum が勝手には拾ってきてくれないので、自分で先に対象ディレクトリに落としておく&lt;/li&gt;
&lt;li&gt;なぜか Docker にインポートした後 RPM DB が壊れているようだったので、 &lt;code&gt;yum clean&lt;/code&gt; 後に &lt;code&gt;rpm --rebuilddb&lt;/code&gt; を実行しておく&lt;/li&gt;
&lt;li&gt;ldconfig キャッシュは消してもいいが、できたイメージをすぐ使いたい時は、ライブラリが見つからなくていちいち再構築も面倒なので、残しておく&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といったところ&lt;/p&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;スクリプトの実行&lt;/h3&gt;

&lt;p&gt;これはそのまんま、上記で作成しておいた &lt;code&gt;yum.conf&lt;/code&gt; を &lt;code&gt;mkimage-yum.sh&lt;/code&gt; に指定して実行するだけである。うまくいけば &lt;code&gt;os_image.tar.gz&lt;/code&gt; がカレントディレクトリ内に作られる&lt;/p&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;Docker でイメージ化&lt;/h3&gt;

&lt;p&gt;できた &lt;code&gt;os_image.tar.gz&lt;/code&gt; を Docker が動いている環境に持ってきて、下記のようにコマンドを実行する&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;cat os_image.tar.gz | docker import - centos-3-i386
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;centos-3-i386&lt;/code&gt; の部分はイメージ名になるので、好きなように設定すればよい。インポートに成功したら、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;docker run -i -t centos-3-i386 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにして使い始めることができる&lt;/p&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;上記の流れでできたイメージを使って、無事パッチ済みの Bash の RPM の作成もできたので、日常の作業には十分な環境が作成できたと思う&lt;/p&gt;

&lt;p&gt;Docker のイメージを作ったのは初めてだったが、 OS が稼働するのに必要なファイル群を tar に固めて食わせるだけ、というのは手軽でいい。各種ディストリビューションごとにマイクロ環境を作れるようなツールがあったりするので、それを使えば気楽にイメージが作れるだろうな、と思う&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HAProxy でのソース IP アドレスアフィニティ設定方法</title>
      <link>http://tatsushid.github.io/blog/2014/09/source-ip-address-affinty-configuration-in-haproxy/</link>
      <pubDate>Mon, 29 Sep 2014 22:11:18 JST</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/09/source-ip-address-affinty-configuration-in-haproxy/</guid>
      <description>

&lt;p&gt;HAProxy で、アクセス元のクライアントの IP アドレスを元に、分散先サーバを固定したい場合、 &lt;code&gt;backend&lt;/code&gt; または &lt;code&gt;listen&lt;/code&gt; セクションで次のように設定すればよい&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;frontend と backend を分けて設定してる場合&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;frontend web-front
	bind *:80
	default_backend web-back

backend web-back
	balance source # Affinity setting
	server s1 192.168.1.11:80 check
	server s2 192.168.1.12:80 check
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;listen でまとめて設定している場合&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;listen web
	bind *:80
	balance source # Affinity setting
	server s1 192.168.1.11:80 check
	server s2 192.168.1.12:80 check
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡単な設定の割にはドキュメントを探すのに結構苦労した&lt;/p&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;参考にしたページ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.haproxy.com/2012/03/29/load-balancing-affinity-persistence-sticky-sessions-what-you-need-to-know/&#34;&gt;load balancing, affinity, persistence, sticky sessions: what you need to know&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cbonte.github.io/haproxy-dconv/configuration-1.5.html#4-balance&#34;&gt;HAProxy Configuration Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Go の構造体とポインタと omitempty の話</title>
      <link>http://tatsushid.github.io/blog/2014/09/go-structure-pointer-and-omitempty/</link>
      <pubDate>Tue, 23 Sep 2014 06:42:55 JST</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/09/go-structure-pointer-and-omitempty/</guid>
      <description>

&lt;p&gt;（下記は go 1.3.1 での話で、異なるバージョンだと動作も違う可能性があるので注意）&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;結論&lt;/h2&gt;

&lt;p&gt;Go で &lt;code&gt;encoding/xml&lt;/code&gt; を使って XML のエンコーディングを行っている時に、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ある特定のタグの子要素ないし属性が一つでもある場合は、そのタグを出力する&lt;/li&gt;
&lt;li&gt;上記のいずれもない場合は、タグは出力しない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を実現したい場合は、単純に要素のポインタ型を使って &lt;code&gt;omitempty&lt;/code&gt; は使わないのが正解&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;詳細&lt;/h2&gt;

&lt;p&gt;上記のケースを最初は単純に&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
	&amp;quot;encoding/xml&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
)

type Foo struct {
	Str string
}

type Bar struct {
	Foo Foo `xml:&amp;quot;,omitempty&amp;quot;`
}

func main() {
	bar := Bar{} // Foo は空
	b, err := xml.MarshalIndent(bar, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b)) // &amp;lt;Bar&amp;gt;&amp;lt;/Bar&amp;gt; と出力されてほしい
	// Output:
	// &amp;lt;Bar&amp;gt;
	//   &amp;lt;Foo&amp;gt;
	//     &amp;lt;Str&amp;gt;&amp;lt;/Str&amp;gt;
	//   &amp;lt;/Foo&amp;gt;
	// &amp;lt;/Bar&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてみたのだけど、うまくいかなかった。理由は &lt;a href=&#34;http://golang.org/pkg/encoding/xml/&#34;&gt;encoding/xml&lt;/a&gt; のドキュメントによると&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;a field with a tag including the &amp;ldquo;omitempty&amp;rdquo; option is omitted
if the field value is empty. The empty values are false, 0, any
nil pointer or interface value, and any array, slice, map, or
string of length zero.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;ということで、空の構造体と比較してはくれないためのよう。ここで対象が &lt;code&gt;nil&lt;/code&gt; ポインタなら空と扱う、と書いてあるので、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
	&amp;quot;encoding/xml&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
)

type Foo struct {
	Str string
}

type Bar struct {
	Foo *Foo `xml:&amp;quot;,omitempty&amp;quot;` // omitempty はあってもなくてもよい
}

func main() {
	bar := Bar{} // Foo は nil
	b, err := xml.MarshalIndent(bar, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b)) // &amp;lt;Bar&amp;gt;&amp;lt;/Bar&amp;gt; と出力されてほしい
	// Output:
	// &amp;lt;Bar&amp;gt;&amp;lt;/Bar&amp;gt;

	bar.Foo = new(Foo)
	b, err := xml.MarshalIndent(bar, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &amp;lt;Bar&amp;gt;
	//   &amp;lt;Foo&amp;gt;
	//     &amp;lt;Str&amp;gt;&amp;lt;/Str&amp;gt;
	//   &amp;lt;/Foo&amp;gt;
	// &amp;lt;/Bar&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と、 &lt;code&gt;Foo&lt;/code&gt; のポインタを構造体に含めるようにしてみるとうまく動く。もちろん要素がある場合も問題なく動く。さらに、この場合は別に &lt;code&gt;omitempty&lt;/code&gt; なしでも意図通りの動作になる&lt;/p&gt;

&lt;p&gt;ところが、たとえば構造体の要素が &lt;code&gt;int&lt;/code&gt; で、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt; の要素が 0 である場合は、要素があるとみなして出力する（つまり &lt;code&gt;omitempty&lt;/code&gt; を無視する）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt; の要素そのものが存在しない時は出力しない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;の場合は、同じようにやっても期待通りにはならない。 &lt;code&gt;int&lt;/code&gt; が 0 の場合は &lt;code&gt;omitempty&lt;/code&gt; の対象として扱ってしまう&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
	&amp;quot;encoding/xml&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
)

type Foo struct {
	Bar *int `xml:&amp;quot;,omitempty&amp;quot;`
}

func main() {
	foo := Foo{}
	b, err := xml.MarshalIndent(foo, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &amp;lt;Foo&amp;gt;&amp;lt;/Foo&amp;gt;

	foo.Bar = new(int)
	*(foo.Bar) = 0
	b, err = xml.MarshalIndent(foo, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &amp;lt;Foo&amp;gt;&amp;lt;/Foo&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合は、要素の型をポインタ型にしつつ、素直に &lt;code&gt;omitempty&lt;/code&gt; を外すか、ポインタのポインタを使うと意図通りの結果が得られるようだ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
	&amp;quot;encoding/xml&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
)

type Foo struct {
	Bar *int
	Baz **int `xml:&amp;quot;,omitempty&amp;quot;`
}

func main() {
	foo := Foo{}
	b, err := xml.MarshalIndent(foo, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &amp;lt;Foo&amp;gt;&amp;lt;/Foo&amp;gt;

	foo.Bar = new(int)
	*(foo.Bar) = 0
	tmp := new(int)
	*tmp = 0
	foo.Baz = &amp;amp;tmp
	b, err = xml.MarshalIndent(foo, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(string(b))
	// Output:
	// &amp;lt;Foo&amp;gt;
	//   &amp;lt;Bar&amp;gt;0&amp;lt;/Bar&amp;gt;
	//   &amp;lt;Baz&amp;gt;0&amp;lt;/Baz&amp;gt;
	// &amp;lt;/Foo&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;いろいろとややこしい&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go でインターフェース型の reflect.Type を取得する方法</title>
      <link>http://tatsushid.github.io/blog/2014/09/how-to-get-reflect-type-of-interface-type-in-go/</link>
      <pubDate>Fri, 19 Sep 2014 21:46:21 JST</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/09/how-to-get-reflect-type-of-interface-type-in-go/</guid>
      <description>&lt;p&gt;Go の &lt;code&gt;reflect&lt;/code&gt; パッケージを使っていて、ときどき操作している変数型との比較のために &lt;code&gt;error&lt;/code&gt; などのインターフェース型の &lt;code&gt;reflect.Type&lt;/code&gt; がほしいことがあるのだけれど、これは &lt;code&gt;reflect.TypeOf((*error)(nil)).Elem()&lt;/code&gt; のように書くことで得られる。つまり、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nil&lt;/code&gt; をほしい型のポインタ型に変換&lt;/li&gt;
&lt;li&gt;それを &lt;code&gt;reflect.TypeOf&lt;/code&gt; に渡してポインタ型の &lt;code&gt;reflect.Type&lt;/code&gt; を取得し&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Elem()&lt;/code&gt; でポインタをデリファレンスしてできる基本型の &lt;code&gt;reflect.Type&lt;/code&gt; を得る&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という流れ。 Go の公式パッケージではよく見かける書法。これを使うと、たとえば変数が &lt;code&gt;error&lt;/code&gt; インターフェースを満たすかどうかの判定は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
        &amp;quot;errors&amp;quot;
        &amp;quot;fmt&amp;quot;
        &amp;quot;reflect&amp;quot;
)

func main() {
	err := errors.New(&amp;quot;A problem occurs&amp;quot;)
	et := reflect.TypeOf(err)
	if et.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
		fmt.Println(&amp;quot;This is an error type&amp;quot;)
	} else {
		fmt.Println(&amp;quot;This isn&#39;t an error type&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように書ける。もちろん、これはリフレクションを操作してる時の話で、普通は&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
        &amp;quot;errors&amp;quot;
        &amp;quot;fmt&amp;quot;
)

func main() {
	err := errors.New(&amp;quot;A problem occurs&amp;quot;)
	if _, ok := err.(error); ok {
		fmt.Println(&amp;quot;This is an error type&amp;quot;)
	} else {
		fmt.Println(&amp;quot;This isn&#39;t an error type&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とするのがよい&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CentOSのyumミラーリストの調べ方</title>
      <link>http://tatsushid.github.io/blog/2014/09/how-to-check-centos-mirrorlist/</link>
      <pubDate>Thu, 18 Sep 2014 22:10:41 JST</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/09/how-to-check-centos-mirrorlist/</guid>
      <description>&lt;p&gt;ここ最近 CentOS の yum で updates からパッケージを持ってくる時の速度がやけに遅いので、 yum にはどんなミラーが返ってきてるのか調べてみた。 yum は 64bit 環境で特別設定を変えてなければ、通常 &lt;code&gt;http://mirrorlist.centos.org/?release=6&amp;amp;arch=x86_64&amp;amp;repo=os&lt;/code&gt; や &lt;code&gt;http://mirrorlist.centos.org/?release=6&amp;amp;arch=x86_64&amp;amp;repo=updates&lt;/code&gt; にアクセスしているので、この URL にブラウザでアクセスするか、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;sh&#34;&gt;curl &#39;http://mirrorlist.centos.org/?release=6&amp;amp;arch=x86_64&amp;amp;repo=os&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のように &lt;code&gt;curl&lt;/code&gt; を使えば、ミラーの一覧が返る。 &lt;code&gt;release&lt;/code&gt; は CentOS のメジャーバージョン、 &lt;code&gt;arch&lt;/code&gt; は &lt;code&gt;i386&lt;/code&gt; や &lt;code&gt;x86_64&lt;/code&gt; などのアーキテクチャ、 &lt;code&gt;repo&lt;/code&gt; はリポジトリの種類をそれぞれ指定できる。さらに、 URL に &lt;code&gt;cc=jp&lt;/code&gt; や &lt;code&gt;ip=8.8.8.8&lt;/code&gt; などのクエリを追加すると、国コード別、 IP アドレス別のミラーリストを返してくれるらしい。たとえば、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;sh&#34;&gt;curl &#39;http://mirrorlist.centos.org/?release=6&amp;amp;arch=x86_64&amp;amp;repo=os&amp;amp;cc=jp&#39; # 国コード別
curl &#39;http://mirrorlist.centos.org/?release=6&amp;amp;arch=x86_64&amp;amp;repo=os&amp;amp;ip=8.8.8.8&#39; # IP アドレス別
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などとすると、それぞれの結果が返る。なお、今日の時点 (2014-09-18) で os の方は&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://ftp.nara.wide.ad.jp/pub/Linux/centos/6.5/os/x86_64/
http://ftp.tsukuba.wide.ad.jp/Linux/centos/6.5/os/x86_64/
http://ftp.iij.ad.jp/pub/linux/centos/6.5/os/x86_64/
http://ftp.jaist.ac.jp/pub/Linux/CentOS/6.5/os/x86_64/
http://ftp.riken.jp/Linux/centos/6.5/os/x86_64/
http://www.ftp.ne.jp/Linux/packages/CentOS/6.5/os/x86_64/
http://mirror.fairway.ne.jp/centos/6.5/os/x86_64/
http://mirror.vodien.com/centos/6.5/os/x86_64/
http://mirror.nus.edu.sg/centos/6.5/os/x86_64/
http://centos.mirror.secureax.com/6.5/os/x86_64/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のような結果が返ってくるが、 updates の方はなぜか&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://mirrors.hust.edu.cn/centos/6.5/updates/x86_64/
http://mirrors.yun-idc.com/centos/6.5/updates/x86_64/
http://centos.mirror.cdnetworks.com/6.5/updates/x86_64/
http://ftp.yzu.edu.tw/Linux/CentOS/6.5/updates/x86_64/
http://ftp.isu.edu.tw/pub/Linux/CentOS/6.5/updates/x86_64/
http://mirror.awanti.com/centos/6.5/updates/x86_64/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようなリストを返してきてて、国内ミラーを使ってくれてないのが速度が出てない理由なのかな、と&lt;/p&gt;

&lt;p&gt;余談だけど、各国のミラーの状態は &lt;a href=&#34;http://mirror-status.centos.org/&#34;&gt;http://mirror-status.centos.org/&lt;/a&gt; で見れる&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>静的サイトジェネレーターを Hugo に切り替えた</title>
      <link>http://tatsushid.github.io/blog/2014/08/change-site-generator-to-hugo/</link>
      <pubDate>Sat, 16 Aug 2014 14:00:00 JST</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/08/change-site-generator-to-hugo/</guid>
      <description>&lt;p&gt;ここ半年から一年の間、ちょっとしたコマンドラインツールの開発にはずっと golang を使ってきてて、せっかくなのでサイトジェネレーターもこの際 golang 製に変えてみようということで、 &lt;a href=&#34;http://hugo.spf13.com/&#34;&gt;Hugo&lt;/a&gt; を使ってみることにした。今のところの使用感としては、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;バイナリ拾ってくるだけなのでインストール簡単&lt;/li&gt;
&lt;li&gt;サイト生成速度が速い！&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt; と同様に Front Matter がある（各ページのメタデータを定義できるもの）&lt;/li&gt;
&lt;li&gt;他のツールにもあるが、ローカルサーバでのプレビュー機能便利&lt;/li&gt;
&lt;li&gt;他のツールほどメジャーではないせいか、既成のテンプレートが少ない (´；ω；｀)&lt;/li&gt;
&lt;li&gt;Go 標準のテンプレートパッケージ使ってるためか、テンプレートでいろいろやろうとすると制約が厳しい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といったところ。 golang の特質はそのままのため、がんばって言語環境整備しなくても、 Windows とか他のプラットフォームでも同じように使えるのはいいところだと思う。コード量もそれほどではないので、自分で機能を追加するのもそれほど難しくない&lt;/p&gt;

&lt;p&gt;一方でテンプレートは本当に選択肢が少なすぎるので、勉強も兼ねて、 &lt;a href=&#34;http://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt; 用のテーマの &lt;a href=&#34;http://lanyon.getpoole.com/&#34;&gt;Lanyon&lt;/a&gt; を移植して、それにちょっとだけ手を加えたものを使うことにした。こちらは気が向いたら公開したい&lt;/p&gt;

&lt;p&gt;このテンプレートを作っていてわかったのは、 golang 標準の text/template と派生の html/template のテンプレートパッケージでは、書式自体は分かりやすくていいものの、制御構文が少なかったり定義した変数のスコープの絡みとかでいろいろと制約があり、プログラム側に手を入れて補助関数を作らないと、単純なものでも機能実現できないものが多々あるなあというところ。この辺りは、ロジックはあくまでプログラム側で処理し、テンプレートはそれを表示するだけだ、という考え方でできているのだと思うが、ちょっとしたカスタマイズでプログラム自体に手を入れなければいけないのは、メンテナンスの面でちょっとつらい。柔軟性の高い補助関数とかが Hugo 本家に入るのを見ていくしかないのかな、という気もする&lt;/p&gt;

&lt;p&gt;ともあれ、 Hugo 自体は必要十分な機能がよくまとまっていて、何よりサイト生成が早いこともあって、気軽に何度でもトライアンドエラーを繰り返して試せるので、個人的には気に入っている。しばらくいろいろ試してみたいと思う&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>wgetでの保存先ディレクトリを指定する</title>
      <link>http://tatsushid.github.io/blog/2014/08/specify-wget-savedir/</link>
      <pubDate>Mon, 11 Aug 2014 16:54:00 JST</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/08/specify-wget-savedir/</guid>
      <description>&lt;p&gt;wget コマンドを使っていると、たまにカレントディレクトリではなくて他の場所にデータを保存したい時があるのだけれど、その方法をしばしば忘れるのでメモ。これをやりたい時は、 -P オプションを使えばよい。たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;wget -P path/to/dstdir http://localhost/path/to/srcfile.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の様に実行すると、 &lt;code&gt;path/to/dstdir/srcfile.tar.gz&lt;/code&gt; の様に保存される&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CentOS7をGPTパーティションで新規インストールする</title>
      <link>http://tatsushid.github.io/blog/2014/07/install-centos7-on-gpt-drive/</link>
      <pubDate>Fri, 25 Jul 2014 13:04:00 JST</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/07/install-centos7-on-gpt-drive/</guid>
      <description>&lt;p&gt;CentOS 7 を GPT パーティションでインストールするのは難しくない。 &lt;a href=&#34;https://bugzilla.redhat.com/show_bug.cgi?id=1032428&#34;&gt;Bug 1032428 - Need a 1MB &amp;lsquo;biosboot&amp;rsquo; type partition when install RHEL7 on a GPT disk with custom partition&lt;/a&gt; によると、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2TB 未満のディスクを使用すると自動的に MSDOS パーティションを使用&lt;/li&gt;
&lt;li&gt;2TB 以上のディスクを使用すると自動的に GPT パーティションを使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という形となっているため、通常は意識して選択する必要がない。また、 2TB 未満のディスクも GPT パーティションとしてインストールしたければ、インストール CD からインストーラーをブートする時のカーネルオプションに inst.gpt を指定しておくと、ディスク種別にかかわらず GTP パーティションが使われるようになる&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CentOS5をGPTパーティションで新規インストールする</title>
      <link>http://tatsushid.github.io/blog/2014/07/install-centos5-on-gpt-drive/</link>
      <pubDate>Tue, 08 Jul 2014 20:06:00 JST</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/07/install-centos5-on-gpt-drive/</guid>
      <description>&lt;p&gt;CentOS 5 の新規インストール時に GTP パーティションを使いたい場合は、 CentOS 6 の様に一筋縄では行かない。今回は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.endpoint.com/2013/11/installing-centos-5-on-3tb-drive.html&#34;&gt;Installing CentOS 5 on a 3 TB Drive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.tkr.mydns.jp/index.php?title=Linux関連/CentOS5_GPT_対応インストール手順&#34;&gt;CentOS5 GPT 対応インストール手順&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を参考に、下記のような手順で仮想マシン作成作業を行ってみた&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ネットワークインストール用の ISO イメージをダウンロードし、仮想マシンに CD イメージとして読み込ませる設定を行う&lt;/li&gt;
&lt;li&gt;起動選択画面で &lt;code&gt;linux resque&lt;/code&gt; と入力し、レスキューモードでサーバを起動する&lt;/li&gt;
&lt;li&gt;起動後は言語選択、キーボード設定、ネットワーク設定、レスキューモード用イメージのダウンロード先を指定して進める。既存 OS 選択画面では Skip を選択して進める&lt;/li&gt;

&lt;li&gt;&lt;p&gt;レスキューモードのシェルが立ち上がるので、下記のようにコマンドを実行してディスクのパーティションを切る&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;parted /dev/sda
(parted) mklabel gpt
(parted) mkpart primary ext3 0 200MB
(parted) mkpart primary linux-swap 200MB 2248MB
(parted) mkpart primary ext3 2248MB 21.5GB
(parted) set 1 boot on
(parted) quit
mkfs.ext3 /dev/sda1
mkfs.ext3 /dev/sda3
mkswap /dev/sda2
tune2fs -c 0 -i 0 /dev/sda1
tune2fs -c 0 -i 0 /dev/sda3
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;そのままでは Anaconda のエラーメッセージが出てインストール処理を先に進められないので、 Anaconda を下記の手順で上書きする&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;mkdir /mnt/anaconda
mount -t tmpfs none /mnt/anaconda
cd /mnt/anaconda
tar -cpf - -C /mnt/runtime/usr/lib/anaconda . | tar -xpf -
vi partitions.py # ここで 1082 行目の errors を warnings に書き換えて保存する
mount -o bind /mnt/anaconda /mnt/runtime/usr/lib/anaconda
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;このまま Anaconda を起動すると &lt;code&gt;/sbin&lt;/code&gt; が存在しているというエラーが出て起動できないため、下記の手順で空の &lt;code&gt;/sbin&lt;/code&gt; を用意する&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;export PATH=$PATH:/sbin.bak
mv /sbin /sbin.bak
mkdir /sbin
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Anaconda の起動準備が完了したので、適切なミラーサイトの URL を使って Anaconda を起動する&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;anaconda --dmraid --selinux -T -m &amp;quot;http://ftp.iij.ad.jp/pub/linux/centos/5/os/x86_64/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;インストール処理は、ディスクのパーティション設定以外、いつもの通りに進める。パーティション設定の画面では、すでに作成されているパーティションにマウントポイントを割り当てるにとどめ。パーティションの再フォーマットなどは行わない。 GPT では起動できないとの警告が出たら、そのまま OK を押して進める&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;インストールが終わったら再起動を行うが、その前に、後の GRUB のインストール作業のために、 ISO イメージを CentOS 5 のものから CentOS 6 のものに差し替えておく&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;再起動を行う。そのまま再起動ボタンを押しても、 Anaconda が終了するだけで再起動処理が行われないので、 &lt;code&gt;Ctrl+Alt+Delete&lt;/code&gt; を入力するなどして再起動する&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CentOS 6 のディスクで起動してきたら、レスキューモードを選択して進める。言語選択、キーボード設定を行うが、ネットワーク設定は不要。既存 OS 選択画面では Skip を選択して進める&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;シェルが立ち上がったら下記の手順で &lt;code&gt;/boot&lt;/code&gt; パーティションをマウントし、必要な GRUB のファイルを上書きする&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;mkdir /boot
mount /dev/sda1 /boot
cp /usr/share/grub/x86_64-redhat/e2fs_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/fat_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/ffs_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/iso9660_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/jfs_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/minix_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/reiserfs_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/stage1 /boot/grub/
cp /usr/share/grub/x86_64-redhat/stage2 /boot/grub/
cp /usr/share/grub/x86_64-redhat/ufs2_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/vstafs_stage1_5 /boot/grub/
cp /usr/share/grub/x86_64-redhat/xfs_stage1_5 /boot/grub/
umount /boot
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ファイルを上書きしたら、 MBR へ GRUB をインストールする&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;grub
grub&amp;gt; root (hd0,0)
grub&amp;gt; setup (hd0)
grub&amp;gt; quit
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GRUB のインストールが完了したら、 ISO イメージを取り出し、再起動を行う&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上の手順で、 GTP パーティションが有効な状態で、新規インストールした CentOS 5 が起動できた&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CentOS6をGPTパーティションで新規インストールする</title>
      <link>http://tatsushid.github.io/blog/2014/07/install-centos6-on-gpt-drive/</link>
      <pubDate>Mon, 07 Jul 2014 19:15:00 JST</pubDate>
      
      <guid>http://tatsushid.github.io/blog/2014/07/install-centos6-on-gpt-drive/</guid>
      <description>&lt;p&gt;毎度毎度コマンドの打ち方を忘れてしまうのでメモ。 RHEL 6 互換のディストリビューションを新規インストールする際、 GPT パーティションを使いたい場合は、インストーラーで適当なところ（パーティション設定の直前辺り）まで進めたところで下記のようにコマンドを実行すると、自分でパーティションを切ることができる&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Alt + Ctrl + F2&lt;/code&gt; でターミナルに切り替える&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parted /dev/sdx&lt;/code&gt; （ sdx は実際のデバイス名を指定）を実行する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mklabel gpt&lt;/code&gt; と入力して実行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;quit&lt;/code&gt; を入力して parted を抜ける&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Alt + F6&lt;/code&gt; でターミナルを抜ける&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上のように実行すると、ディスクデバイスに GPT パーティションが設定される。後は普通にパーティション設定を行ってインストールを進めていけば、 GPT パーティションのサーバができあがる&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>